[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "MA32011",
    "section": "",
    "text": "Preface\nWelcome to the module MA32011 Dynamical systems.\nMy name is Philip Murray and I am the module lead.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#how-to-contact-me",
    "href": "index.html#how-to-contact-me",
    "title": "MA32011",
    "section": "How to contact me?",
    "text": "How to contact me?\n\nemail: pmurray@dundee.ac.uk\noffice: G11, Fulton Building\nTeams: PM me",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#lecture-notes",
    "href": "index.html#lecture-notes",
    "title": "MA32011",
    "section": "Lecture notes",
    "text": "Lecture notes\nYou can find lecture notes for the module on this page. If you would like a pdf this can be easily generated by clicking on the pdf link of the webpage. I will occasionally edit/update the notes as we proceed through lectures. If you spot any errors, typos or omissions please let me know.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#reading",
    "href": "index.html#reading",
    "title": "MA32011",
    "section": "Reading",
    "text": "Reading\nNonlinear dynamics and chaos, Steven Strogatz Strogatz (2001) Mathematical Biology I, Murray (2002)",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#python-codes",
    "href": "index.html#python-codes",
    "title": "MA32011",
    "section": "Python codes",
    "text": "Python codes\nI have provided Python codes for most of the figures in the notes (you can unfold code section by clicking `Code’). Note that the Python code does not appear in the pdf.\nMany of you have taken the Introduction to Programming module at Level 2 and have therefore some experience using Python. I strongly encourage you to use the provided codes as a tool to play around with numerical solutions of the various models that we will be working on. The codes should run as standalone Python codes.\n\n\n\n\n\n\nNote\n\n\n\nTo access Python on Uni machines:\n\nLaunch Anaconda from AppsAnywhere\nWhen a folder opens, double click on Spyder.\nPaste a code from lecture notes into the editor on the left-hand side.\nClick on the green arrow to run the code.\nThe plots should appear in the plots tab on the right-hand side.\nExperiment with the code. When you change a model parameter, does the solution change in an expected way?\n\n\n\nI have also provided some examples of how to use Python as a symbolic calculator. This uses a Python library called sympy and is quite similar to Maple.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#assessment",
    "href": "index.html#assessment",
    "title": "MA32011",
    "section": "Assessment",
    "text": "Assessment\n\nFinal exam (80 %)\n2 class tests (8 % each), Week 7 and 11\n4 quizes (1 % each), Week 2,4,6 and 9",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#plan",
    "href": "index.html#plan",
    "title": "MA32011",
    "section": "Plan",
    "text": "Plan\n\nProjected delivery\n\n\nWeek\nUp to Section\nTutorial sheet\nAssessment\n\n\n\n\n1\n\n1\n\n\n\n2\n\n1\nQuiz 1\n\n\n3\n\n2\n\n\n\n4\n\n2\nQuiz 2\n\n\n5\n\n3\n\n\n\n6\n\n3\nQuiz 3\n\n\n7\n\n4\nTest 1\n\n\n8\n\n4\n\n\n\n9\n\n5\nQuiz 4 4\n\n\n10\n\n5\n\n\n\n11\n\nTest 2",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#references",
    "href": "index.html#references",
    "title": "MA32011",
    "section": "References",
    "text": "References\n\n\n\n\nMurray, J. D. 2002. Mathematical Biology i: An Introduction. Springer.\n\n\nStrogatz, Steven H. 2001. Nonlinear Dynamics and Chaos: With Applications to Physics, Biology, Chemistry, and Engineering (Studies in Nonlinearity). Vol. 1. Westview press.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introduction",
    "section": "",
    "text": "1.1 Discrete v continuous time\nThe goal of this module is to provide an introduction to dynamical systems. We will introduce key mathematical concepts and explore examples from physics and biology.\nTo begin with we introduce some key terminology.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "intro.html#discrete-v-continuous-time",
    "href": "intro.html#discrete-v-continuous-time",
    "title": "1  Introduction",
    "section": "",
    "text": "1.1.1 Differential equations\nLet \\(t\\) be a continuous variable and \\(x=x(t)\\). \\(\\dot{x}\\) is used to denote the time derivative, i.e. \\[\n\\dot{x}:=\\frac{dx}{dt}.\n\\]\nSimilarly, the second order derivative is represented by \\[\n\\ddot{x}:=\\frac{d^2x}{dt^2}.\n\\]\n\n1.1.1.1 Population dynamics\nMany of the biological examples that we will encounter later describe population dynamics. Let \\(N(t)\\) represent the size of a population at time \\(t\\).\nSuppose that individuals are born at per capita constant rate \\(b\\) and die at a rate \\(d\\).\nWe can write \\[\nN(t+\\Delta t)=N(t)+bN(t)\\Delta t -dN(t)\\Delta t\n\\]\nGathering terms and taking the limit \\(\\Delta t \\rightarrow 0\\) yields \\[\n\\dot{N}=(b-d)N.\n\\]\nIf we allow the birth and death rates to depend on population size then we can derive a more general equation \\[\n\\dot{N}=H(N),\n\\] where \\(H\\) is some prescribed function. An example is the logistic growth equation \\[\n\\dot{N}=rN(1-N).\n\\tag{1.1}\\]\n\n\n1.1.1.2 Newton’s second law\nMany of the physics examples that we will examine later originate from Newton’s Second Law, i.e.\n\\[\nm\\ddot{x}=F(x,\\dot{x}),\n\\] where \\(x(t)\\) represents the position of a particle at time, \\(t\\), \\(m\\) represents a constant particle mass and \\(F\\) a resultant force.\nConsider the case in which \\(F\\) represents a linear restoring force, i.e. \\[\nF(x,\\dot{x})=-kx.\n\\] The equation of motion can be written as \\[\n\\ddot{x}=-\\mu x,\n\\tag{1.2}\\] where \\(\\mu=-k/m\\).\n\nExample 1.1 The app encodes a numerical solution of the second order ODE\n\\[\na\\ddot{x}+b\\dot{x}+cx=0.\n\\]\nUse the app to:\n\nidentify appropriate values of the parameters \\(a\\), \\(b\\) and \\(c\\) so that the solution captures the case of a particle of mass (\\(m\\)) equal to 3 subjected to a linear restoring force with spring constant (\\(k\\)) equal to 5.\nexplore the dependence of oscillation period on initial conditions.\n\nIs the behaviour of the numerical solution consistent with Equation 1.2?\n\n\n\n#| '!! shinylive warning !!': |\n#|   shinylive does not work in self-contained HTML documents.\n#|   Please set `embed-resources: false` in your metadata.\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 800\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\n\napp_ui = ui.page_fluid(\n    ui.input_slider(id=\"a\",label=\"a\",min=0.01,max=3,value=0.1,step=0.001),\n    ui.input_slider(id=\"b\",label=\"b\",min=0.0,max=15.0,value=10.0,step=0.1),             \n    ui.input_slider(id=\"c\",label=\"c\",min=0.0,max=30.0,value=5.0,step=1.0),   \n    ui.input_slider(id=\"y0\",label=\"x(t=0)\",min=0.0,max=20.0,value=5.0,step=1.0),\n    ui.input_slider(id=\"y0p\",label=\"dx/dt(t=0)\",min=0.0,max=20.0,value=1,step=1.0),\n    ui.input_slider(id=\"T\",label=\"Simulation time\",min=0.0,max=60.0,value=20.0,step=0.5),\n        ui.output_plot(\"plot\"),\n)\n\ndef server(input, output, session):\n    \n    @render.plot\n    def plot():\n        fig, ax = plt.subplots()\n        #ax.set_ylim([-2, 2])\n        # Filter fata\n        \n        \n        a=float(input.a())\n        b=float(input.b())\n        c=float(input.c())\n        y_0=float(input.y0())\n        y_0_p=float(input.y0p())\n        T=float(input.T())\n        \n\n        \n        # Define rhs of LV ODEs\n        def rhs_pop_model(y,t,a,b,c):\n          rhs=np.zeros_like(y,dtype=float)\n\n          z=y[1]\n\n          #ay'' + by'+cy=0\n          # y'=z\n          # z'=y''=-(by'+cy)/a\n\n\n          dy_dt=y[1]\n          dz_dt=-(b*z+c*y[0])/a\n\n          rhs[0]=dy_dt\n          rhs[1]=dz_dt\n\n          return rhs\n\n        # Define discretised t domain\n        t = np.linspace(0, T, 1000)\n\n        # define initial conditions\n        init_cond=[y_0,y_0_p]\n        \n        # Compute numerical solution of ODEs\n        sol1 = odeint(rhs_pop_model, init_cond,t,args=(a,b,c))\n\n        # Plot results\n        y=sol1[:,0]\n        yp=sol1[:,1]\n        \n        \n        ax.plot(t, y)\n        ax.set_xlabel('$t$')\n        ax.set_ylabel('$x(t)$')\n\n        plt.grid()\n        #plt.show()\n    \napp = App(app_ui, server)\n\n\nFigure 1.1: Exploring numerical solutions of a linear second order ODE.\n\n\n\n\n\n1.1.2 Difference equations\nSuppose that \\(n\\) is a discrete variable. Let \\(y_n\\) represent a dependent variable at iteration \\(n\\). Consider the difference equation \\[\ny_{n+1}=ry_n(1-y_n),\n\\] where \\(r\\in \\Re\\).\n\nExample 1.2 Use the app below to 1. explore how the solution behaviour (top row) changes qualitatively as the parameter \\(r\\) increases. 2. connect the branching structure in the bifurcation diagram (second and third rows) to the qualitative behaviour of the solution (top row). 3. demonstrate self similarity (by zooming in on the bifurcation diagram (bottom row) show that the structure appears to repeat at finer scales).\n\n\n\n#| '!! shinylive warning !!': |\n#|   shinylive does not work in self-contained HTML documents.\n#|   Please set `embed-resources: false` in your metadata.\n#| standalone: true\n#| viewerHeight: 800\n\n\n\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\n\napp_ui = ui.page_fluid(\n                 \n    ui.input_slider(id=\"u0\",label=\"u_0\",min=0.0,max=1.0,value=0.5,step=0.01),\n    ui.input_slider(id=\"T\",label=\"Number of iterations\",min=0.0,max=60.0,value=20.0,step=1.0),\n    ui.input_slider(id=\"r_range\",label=\"r zoomed\",min=0.0,max=4.0,value=[0.0,4.0],step=0.001),\n    ui.input_slider(id=\"u_range\",label=\"u zoomed\",min=0.0,max=1.0,value=[0.0,1.0],step=0.01),ui.output_plot(\"plot\"),\n    ui.input_slider(id=\"r\",label=\"r\",min=0.0,max=5.0,value=0.1,step=0.001),\n)\n\ndef server(input, output, session):\n    @output\n    @render.plot\n    def plot():\n        fig, ax = plt.subplots(3,1,figsize=(12, 4))\n        #ax.set_ylim([-2, 2])\n        # Filter fata\n        \n        \n        r=float(input.r())\n        u0=float(input.u0())\n        T=int(input.T())\n        r_min=float(input.r_range()[0])\n        r_max=float(input.r_range()[1])\n        u_min=float(input.u_range()[0])\n        u_max=float(input.u_range()[1])\n\n\n        # Define rhs of logistic map \n        def logistic_map(y,t,r):\n          rhs=r*y*(1-y)\n          return rhs\n        \n        def DiscreteSol(rhs_pop_model,y_0,t,r):\n            y=np.zeros_like(t,dtype=float)\n            y[0]=y_0\n            for i in t:\n                if i&gt;0:\n\n                    y[i]=rhs_pop_model(y[i-1],t[i],r)\n            return y\n\n        # Define discretised t domain\n        t = np.arange(0, T, 1)\n        # define initial conditions\n        init_cond=u0\n        \n        # Compute numerical solution of ODEs\n        sol1 = DiscreteSol(logistic_map,init_cond,t,r)\n\n        # Plot results\n        y=sol1\n        \n        ax[0].plot(t,y)\n        ax[0].set_xlabel('$n$')\n        ax[0].set_ylabel('$y_n$')\n        ax[0].set_ylim([-0.05,1.05])\n\n        plt.grid()\n\n        # Parameters\n        n_iterations = 1000  # total iterations for each value of r\n        n_last = 100         # number of iterations to plot (for steady state)\n        r_values = np.linspace(0.0, 4.0, 10000)  # range of r values\n        u0 = 0.5  # initial population (seed)\n\n        delta=0.25\n        #r_min=r-delta\n        #r_max=r+delta\n\n        r_values2 = np.linspace(r_min, r_max, 10000)  # range of r values\n\n        # Initialize plot\n        x = np.full_like(r_values, u0)\n        x2 = np.full_like(r_values2, u0)\n\n        # Iterate and plot bifurcation diagram\n         \n        for _ in range(n_iterations):\n            x = r_values * x * (1 - x)  # logistic map function\n            x2 = r_values2 * x2 * (1 - x2)  # logistic map function\n\n            if _ &gt;= (n_iterations - n_last):  # plot only steady state\n                ax[1].plot(r_values, x, ',k', alpha=0.25)\n                ax[1].plot([r,r],[0,1],'r--')\n                ax[2].plot(r_values2, x2, ',k', alpha=0.25)\n                ax[2].plot([r,r],[0,1],'r--')\n\n            # Labels and display\n            ax[1].set_title(\"Bifurcation Diagram\")\n            ax[1].set_xlabel(\"$r$\")\n            ax[1].set_ylabel(\"$y^*$\")\n            ax[2].set_title(\"Bifurcation Diagram (zoomed in) \")\n            ax[2].set_xlabel(\"$r$\")\n            ax[2].set_ylabel(\"$y^*$\")\n            ax[2].set_xlim([r_min,r_max])\n            ax[2].set_ylim([u_min,u_max])\n\n\n\n        plt.show()\n    \napp = App(app_ui, server)\n\n\nFigure 1.2: Exploring behaviour of the logistic map using numerical solutions and bifurcation diagrams.\n\n\n\n\n1.1.3 Key questions to ask of a dynamical system\n\ndo solutions exist? If so are they unique?\nIs there an explicit solution?\nCan we qualitatively describe solution behaviour?\nHow do the solutions depend on the model parameters?\nAre their critical values of parameters where solution behaviour changes?",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "intro.html#autonomous-v-nonautonomous-odes",
    "href": "intro.html#autonomous-v-nonautonomous-odes",
    "title": "1  Introduction",
    "section": "1.2 Autonomous v nonautonomous ODEs",
    "text": "1.2 Autonomous v nonautonomous ODEs\nFor an autonomous system, the update does not explicitly depend on the independent variable. Equation 1.1 is autonomous. But \\[\n\\dot{x}=rx(1-x+t)\n\\] is nonautonomous (because of the explicit time dependence on the right-hand side).",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "intro.html#linear-v-nonlinear",
    "href": "intro.html#linear-v-nonlinear",
    "title": "1  Introduction",
    "section": "1.3 Linear v Nonlinear",
    "text": "1.3 Linear v Nonlinear\nLinear systems satisfy a linear supposition principle: a sum of solutions is itself a solution. In general, this property does not hold for nonlinear systems.\nIn linear dynamical systems, the dynamics are a function of linear sums of the dependent variables. Hence\n\\[\n\\dot{x}=-x\n\\tag{1.3}\\] is a linear ordinary differential equation (ODE). But \\[\n\\dot{x}=-x^2\n\\tag{1.4}\\] is nonlinear.\n\nExample 1.3 Integrate each of Equation 1.3 and Equation 1.4. Use the solutions to demonstrate that the principle of linear superpositions holds for Equation 1.3 but not for Equation 1.4.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "intro.html#quantitative-v-qualitative-solutions",
    "href": "intro.html#quantitative-v-qualitative-solutions",
    "title": "1  Introduction",
    "section": "1.4 Quantitative v qualitative solutions",
    "text": "1.4 Quantitative v qualitative solutions\nYou are likely used to solving problems in which an explicit solution can be found. For example, consider the ODE \\[\n\\dot{x}=-kx, \\quad  x(0)=x_0\n\\] where \\(k,x_0 \\in \\Re^+\\) .\nWe can integrate and express the solution as\n\\[\nx(t)=x_0e^{-kt}\n\\]\nUsing the explicit solution we can then answer questions about its behaviour. For example, let’s say we want to find the time, \\(t^*\\), at which the solution is half it’s maximum. Hence \\[\nx(t*)=x_0/2 \\implies t^* = \\frac{\\ln 2}{k}.\n\\]\nHowever, almost all problems that we will encounter in the study of nonlinear systems will not have an explicit solution. For example, consider the nonlinear ODE\n\\[\n\\dot{x}=-\\frac{k\\sin(x)+\\sqrt{x}}{1+x}, \\quad  x(0)=x_0,\n\\] where \\(0&lt;x_0&lt;\\pi\\).\nI cannot integrate this equation in order to find solutions in terms of standard functions. Hence I cannot quantitatively describe the solution. However, I can identify that\n\\[\n\\dot{x}&lt;0, \\  \\forall \\  0&lt;x&lt;\\pi.\n\\]\nHence the solution will decrease in value from the given initial condition and tend to zero as \\(t\\rightarrow \\infty\\). This is an example of a qualitative analysis.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "intro.html#representing-solutions",
    "href": "intro.html#representing-solutions",
    "title": "1  Introduction",
    "section": "1.5 Representing solutions",
    "text": "1.5 Representing solutions\nIt is useful to define some important concepts that are used to describe the solutions of a dynamical system. Consider an ODE \\[\n\\dot{\\mathbf{x}}=\\mathbf{f}(\\mathbf{x}), \\quad \\mathbf{x}(0)=\\mathbf{x}_0,\n\\] where \\(\\mathbf{f}\\) is a prescribed function and \\(\\mathbf{x}_0\\) is an initial condition.\n\nphase space - a Cartesian coordinate system with dependent variables represented on Cartesian axes\nphase point - value of the solution at given time point\nvector field - the derivative of the solution, i.e. \\(\\mathbf{f}\\).\ntrajectory - a line in phase space that traces out a solution as time evolves (must be tangential to vector field)\nphase portrait - collection of trajectories (i.e. solutions with different initial conditions)",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "intro.html#fixed-points-and-their-stability",
    "href": "intro.html#fixed-points-and-their-stability",
    "title": "1  Introduction",
    "section": "1.6 Fixed points and their stability",
    "text": "1.6 Fixed points and their stability\nMany of the dynamical systems that we will study will be nonlinear. Hence it will not be possible to compute exact solutions.\nThe behaviour of dynamical systems can often be understood by considering the fixed points, i.e. values of the dependent variables at which the dynamics are at steady state.\nStability analyses are used to investigate the dynamics of perturbations about the steady state.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "intro.html#uniqueness-and-existence",
    "href": "intro.html#uniqueness-and-existence",
    "title": "1  Introduction",
    "section": "1.7 Uniqueness and existence",
    "text": "1.7 Uniqueness and existence\nWe will restrict ourselves to problems in which the vector fields are sufficiently well behaved such that unique solutions exist.\n\nTheorem 1.1 TheoremSuppose that \\[\n\\dot{{x}}=f(x), \\quad x(0)=x_0.\n\\tag{1.5}\\]\nIf \\(f\\) is continuously differentiable on an open interval \\(D\\) of the \\(x\\) axis and \\(x_0\\) is a point in \\(D\\), Equation 1.5 possesses a unique solution on some time interval \\((-\\tau,\\tau)\\).\n\n\nHowever, it is noted that problems can be identified where solutions do not exist or where multiple solutions exist.\n\nExample 1.4 Show that the solution to the ODE \\[\n\\dot{x}=x^2 \\quad x(0)=2\n\\] blows up after a finite time.\nIs this result consistent with Theorem 1.1?\n\n\nExample 1.5 Show that the solution to the ODE \\[\n\\dot{x}=\\sqrt{x}, \\quad x(0)=0\n\\] is given by \\[\nx=\\begin{cases}\n&0, \\ \\ t\\leq\\delta \\\\\n&\\frac{(t-\\delta)^2}{4}&gt;\\delta, \\  \\ t&gt; \\delta\n\\end{cases}\n\\] for any \\(\\delta &gt;0\\). Why does this form imply that the solution is not unique? Is this result consistent with Theorem 1.1?",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "intro.html#nondimensionalisation",
    "href": "intro.html#nondimensionalisation",
    "title": "1  Introduction",
    "section": "1.8 Nondimensionalisation",
    "text": "1.8 Nondimensionalisation\nIn real world problems, variables and parameters typically have units (e.g. time - seconds, Force - Newtons etc.). We can nondimensionalise problems by defining rescaled variables. This process can be used to justify simplifications to models and to reduce the number of parameters.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "intro.html#numerical-solutions",
    "href": "intro.html#numerical-solutions",
    "title": "1  Introduction",
    "section": "1.9 Numerical solutions",
    "text": "1.9 Numerical solutions\nNumerical solutions are used to numerically compute approximate solutions to problems. The simplest example of a numerical method in a dynamical system is the forward Euler method. Suppose we want to study the ODE\n\\[\n\\dot{x}=f(x), \\quad x(0)=x_0, \\quad 0&lt;t&lt;T.\n\\]\nDiscretise the independent variable \\(t\\) by defining \\(t=0\\),\\(\\Delta t\\),\\(2\\Delta t\\),…,\\(T=N\\Delta T\\).\nApproximate the time derivative\n\\[\n\\dot{x}=\\frac{dx}{dt}\\sim \\frac{x(t+\\Delta t)-x(t)}{\\Delta t}\n\\]\nHence the solution at time \\(t+\\Delta t\\) can be approximated by \\[\nx(t+\\Delta t)=x(t)+\\Delta t f(x(t)).\n\\]\nGiven an initial condition \\(x(0)=a\\) we can compute the approximate solution at time \\(\\Delta t\\). Further iteration then allows an approximate solution to be calculated.\nNumerical solutions provide a a very useful way to explore solution behaviour. However, they describe the quantitative behaviour of a solution for a particular initial condition and set of parameter values.\n\nExample 1.6 The app below uses the Forward Euler method to compute numerical solutions of the ODE \\[\n\\dot{x}=a+bx+cx^2\n\\] in the domain \\([0,T]\\) with initial condition \\[\nx(0)=x_0.\n\\]\n\nChoose model parameters so that the app solves the ODE \\[\n\\dot{x}=-bx, \\quad x(0)=x_0.\n\\] and show that the numerical solution agrees (eye ball norm) with the exact solution (dashed line).\nShow that the numerical error increases with \\(\\Delta t\\).\n\n\n\n\n#| '!! shinylive warning !!': |\n#|   shinylive does not work in self-contained HTML documents.\n#|   Please set `embed-resources: false` in your metadata.\n#| standalone: true\n#| viewerHeight: 800\n\n\n\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\n\napp_ui = ui.page_fluid(\n                 \n    ui.input_slider(id=\"x0\",label=\"x_0\",min=0.0,max=10.0,value=0.5,step=0.01),\n    ui.input_slider(id=\"T\",label=\"T\",min=0.0,max=60.0,value=20.0,step=1.0),\n    ui.input_slider(id=\"a\",label=\"a\",min=-5.0,max=5.0,value=-1.0,step=0.01),\n    ui.input_slider(id=\"b\",label=\"b\",min=-5.0,max=5.0,value=2.0,step=0.01),ui.output_plot(\"plot\"),\n    ui.input_slider(id=\"c\",label=\"c\",min=-5.0,max=5.0,value=0.1,step=0.01),\n    ui.input_slider(id=\"dt\",label=\"dt\",min=0.0,max=1.0,value=0.01,step=0.001),\n)\n\ndef server(input, output, session):\n    @output\n    @render.plot\n    def plot():\n        fig, ax = plt.subplots(1,1,figsize=(12, 4))\n       \n        x0=float(input.x0())\n        T=float(input.T())\n        a=float(input.a())\n        b=float(input.b())\n        c=float(input.c())\n        dt=float(input.dt())\n\n\n        # Define rhs of logistic map \n        def oderhs(y,a,b,c):\n          rhs=a+b*y+c*y**2\n          return rhs\n        \n        def FESol(y_0,t,a,b,c,dt):\n            y=np.zeros_like(t,dtype=float)\n            y[0]=y_0\n            for i in range(len(t)):\n                if i&gt;0:\n                    y[i]=y[i-1]+dt*oderhs(y[i-1],a,b,c)\n            return y\n\n        N=int(np.ceil(T/dt))\n        # Define discretised t domain\n        t = np.linspace(0, T,N)\n        \n        # Compute numerical solution of ODEs\n        sol1 = FESol(x0,t,a,b,c,dt)\n\n        # Plot results\n        y=sol1\n        \n        model_sol=x0*np.exp(b*t)\n        ax.plot(t,y,t,model_sol,'--')\n        ax.set_xlabel('$t$')\n        ax.set_ylabel('$x(t)$')\n        ax.set_ylim([0,2*x0])\n\n        fig.legend(['Num','$x_0e^{bt}$'])\n\n        plt.grid()\n\n        plt.show()\n    \napp = App(app_ui, server)\n\n\nFigure 1.3: Numerical solution of an ODE with a quadratic right-hand side.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "1DFlows.html",
    "href": "1DFlows.html",
    "title": "2  Flows on the line",
    "section": "",
    "text": "2.1 Geometric\nHere we consider ODE models with a single dependent variable that are first order in time.\nLet \\(x=x(t)\\) and consider the ODE \\[\n\\dot{x}=f(x).\n\\tag{2.1}\\]\nIt is assumed that \\(f\\) is smooth and real valued.\nFor many problems an explicit solution can either not be constructed or is not of practical use.\nAfter applying separation of variables, an implicit solution is given by\n\\[\nt=-\\ln |\\csc x + \\cot x| + C,\n\\] where \\(C\\) is an integration constant.\nHowever, this does not help me to describe the limiting behaviour of the solution as \\(t\\rightarrow \\infty\\).\nInstead let’s use a graphical method. In Figure 2.1 we sketch a graph of \\(f\\), the right-hand side of the ODE. The arrows depict the vector field. Hence when \\(f&gt;0\\), \\(\\dot{x}&gt;0\\) and the solution increases. In contrast, when \\(f&lt;0\\), \\(\\dot{x}&lt;0\\) and the solution decreases.\nNote that \\(f&gt;0  \\ \\forall \\ 0&lt;x&lt;\\pi\\). Hence for the initial condition \\(x_0=\\pi/4\\), \\(\\dot{x}_{t=0}&gt;0\\). The solution will increase until it reaches \\(\\pi\\). At \\(x=\\pi\\), \\(f=0\\).",
    "crumbs": [
      "1D flows",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Flows on the line</span>"
    ]
  },
  {
    "objectID": "1DFlows.html#geometric",
    "href": "1DFlows.html#geometric",
    "title": "2  Flows on the line",
    "section": "",
    "text": "Example 2.1 Let \\(x(t)\\). Consider the ODE \\[\n\\dot{x}=\\sin x.\n\\]\nFor the initial condition \\(x(0)=\\pi/4\\), describe solution behaviour as \\(t\\rightarrow \\infty\\).\n\n\n\n\n\n\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nx=np.linspace(-5,5)\n\ny=np.sin(x)\n\nfig,ax=plt.subplots()\n\nax.plot(x,y)\nax.set_xlabel('$x$')\nax.set_ylabel('$\\dot{x}$')\n# Arrow target (arrow head)\nx=[np.pi, np.pi, -np.pi, -np.pi]\ny=[0.0, 0.0,0.0,0.0]\n\n# Arrow start\nx0=[0.0,2.0*np.pi,0.0,-2.0*np.pi]\ny0 = [0.0,0.0,0.0,0.0]\n\n\nfor x_i,y_i,x0_i,y0_i in zip(x,y,x0,y0):\n  ax.annotate('',\n      xy=(x_i, y_i),        # arrow head\n      xytext=(x0_i, y0_i),  # arrow tail\n      arrowprops=dict(\n          arrowstyle='-&gt;',\n          color='black'\n      ),\n      ha='center'\n  )\n  \nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2.1",
    "crumbs": [
      "1D flows",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Flows on the line</span>"
    ]
  },
  {
    "objectID": "1DFlows.html#fixed-points-and-linear-stability",
    "href": "1DFlows.html#fixed-points-and-linear-stability",
    "title": "2  Flows on the line",
    "section": "2.2 Fixed points and linear stability",
    "text": "2.2 Fixed points and linear stability\n\n2.2.1 Fixed points\nLet \\(x=x^*\\) be a fixed point of Equation 2.1. At \\(x=x^*\\) \\[\n\\dot{x}=0 \\implies f(x^*)=0.\n\\]\nThere are a number of interpretations of \\(x^*\\):\n\nroots of \\(f\\) (algebraic)\nstagnation points of the flow (topological)\n\n\nCorollary 1Any trajectory initialised at a fixed point remains there for all \\(t\\).\n\n\n\nExample 2.2 Find all the fixed points of \\[\n\\dot{x}=x^2-1,\n\\tag{2.2}\\]\n\n\nSolutionThe fixed points are point, \\(x^*\\) defined such that \\[\n\\dot{x}=0 \\ \\implies \\ f(x^*)=0.\n\\]\nHence fixed points satisfy \\[\n{x^*}^2-1=0.\n\\]\nThe solutions are \\[\nx^*=\\pm 1.\n\\]\nSee Figure 2.2 for graphical solution.\n\n\n\nCode\nimport numpy as np\n\nx=np.linspace(-2,2)\n\ny=x**2-1\n\nfig,ax=plt.subplots()\n\nax.plot(x,y)\nax.set_xlabel('$x$')\nax.set_ylabel('$f$')\nax.grid(True)\nax.set_ylim([-2,3])\n\n\n# Arrow target (arrow head)\nx=[-1.0, -1.0, 2.0]\ny=[0.0, 0.0,0.0]\n\n# Arrow start\nx0=[-2.0,1.0,1.0]\ny0 = [0.0,0.0,0.0]\n\n\nfor x_i,y_i,x0_i,y0_i in zip(x,y,x0,y0):\n  ax.annotate('',\n      xy=(x_i, y_i),        # arrow head\n      xytext=(x0_i, y0_i),  # arrow tail\n      arrowprops=dict(\n          arrowstyle='-&gt;',\n          color='black'\n      ),\n      ha='center'\n  )\n  \n\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2.2: Graphical solution of Equation 2.2.\n\n\n\n\n\n2.2.2 Linear stability analysis\nLet \\(x=x^*\\) be a fixed point of Equation 2.1.\n\n2.2.2.1 A change of dependent variable\nTo perform a linear stability analysis we make the change of variables \\[\nx(t)=x^*+\\hat{x}(t)\n\\] where the new dependent variable, \\(\\hat{x}(t)\\), is a perturbation about the fixed point.\nThe time derivative on the left-hand side of Equation 2.1 transforms to \\[\n\\dot{x}= \\frac{d }{dt} (x^*) + \\frac{d }{dt}(\\hat{x}(t))=\\dot{\\hat{x}}.\n\\] Hence Equation 2.1 transforms to \\[\n\\dot{\\hat{x}} = f(x^*+\\hat{x}(t)).\n\\tag{2.3}\\]\n\n\n2.2.2.2 Taylor expansion and a linear system\nEmploying the Taylor expansion on the right-hand side of Equation 2.1 and making the assumption that perturbations are small \\[\n\\dot{\\hat{x}} = f(x^*)+  f'(x^*)\\hat{x}(t) + f''(x^*)\\hat{x}^2(t) + h.o.t.\n\\] Noting that\n\\[\nf(x^*)=0\n\\] and retaining linear terms yields \\[\n\\dot{\\hat{x}} =  f'(x^*)\\hat{x}(t)\n\\] with solution \\[\n\\hat{x}(t)=  \\eta e^{f'(x^*) t}.\n\\] Here \\(\\eta\\) is an initial perturbation about the steady-state that is determined by initial conditions.\n\n\n2.2.2.3 A condition for linear stability\nWhen \\(f'(x^*)&gt;0\\) the perturbation grows exponentially fast and the steady-state is linearly unstable. When \\(f'(x^*)&lt;0\\) the perturbation decays exponentially fast and the steady-state is linearly stable.\n\nExample 2.3 Determine the linear stability of the fixed points of \\[\n\\dot{x}=x^2-1.\n\\]\n\n\nExample 2.4 What can be said about the stability of the fixed points of the following ODEs:\n\n\\[\n\\dot{x}=-x^3.\n\\]\n\\[\n\\dot{x}=x^3.\n\\]\n\\[\n\\dot{x}=0.\n\\]",
    "crumbs": [
      "1D flows",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Flows on the line</span>"
    ]
  },
  {
    "objectID": "1DFlows.html#validity-of-linear-classification",
    "href": "1DFlows.html#validity-of-linear-classification",
    "title": "2  Flows on the line",
    "section": "2.3 Validity of linear classification",
    "text": "2.3 Validity of linear classification\nIt is worth highlighting here that\n\\[\nf'(x*)\n\\] can be interpreted as an eigenvalue of the linearised problem \\[\n\\dot{\\hat{x}}=\\lambda \\hat{x},\n\\] where \\[\n\\lambda = f'(x^*).\n\\]\n\nDefinition 2A fixed point is said to be hyperbolic when the eigenvalues of its linearisation are nonzero.\n\n\n\nTheorem 3: Hartman-GrobmanIf a system has a hyperbolic FP, the classification of the nonlinear system at the fixed point is determined by the linear classification.\n\n\nIf a fixed point is non-hypberbolic, it’s classification requires consideration of higher order terms.\n\nExample 2.5 Apply the Hartman Grobman theorem to the classification of the problem\n\\[\n\\dot{x}=-x^3.\n\\]",
    "crumbs": [
      "1D flows",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Flows on the line</span>"
    ]
  },
  {
    "objectID": "1DFlows.html#case-study-population-dynamics",
    "href": "1DFlows.html#case-study-population-dynamics",
    "title": "2  Flows on the line",
    "section": "2.4 Case study: population dynamics",
    "text": "2.4 Case study: population dynamics\nLet \\(N=N(t)\\). The logistic model of population growth, due to Verhulst, takes the form \\[\n\\dot{N}=rN(t)\\left (1-\\frac{N(t)}{K}\\right),\n\\tag{2.4}\\]\nwhere \\(r\\) is the linear growth rate and \\(K\\) is carrying capacity. We consider both \\(r,K\\in \\Re^+\\).\nQuestions to ask of such a model are: what type of biologically realistic solutions does it possess? Are there fixed points? If so, are they stable or unstable?\n\n2.4.0.1 Numerical solutions\nIn Figure 2.3 we present numerical solutions of equation using different initial conditions. Note the limiting behaviour of solutions as \\(t\\rightarrow \\infty\\). In Figure 2.3 it is clear that even though some solutions are initialised at \\(N_0=0.1\\), much closer to \\(N^*=0\\) than \\(N^*=K\\), they tend to the limit \\(N=K\\). Why do solutions not tend to \\(N^*=0\\)?\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport scipy\nfrom scipy.integrate import odeint\n# This codes computes a numerical solution of the logistic growth model\n\n\n# Define model parameters\nK=12\nr_1=0.22\nr_2=0.42\nr_3=0.72\n\n# Plotting parameter\nN_max=1.1\n\n# Initial condition\nn_0=1.5\n# Max time\nT=20\nt=np.linspace(0,T,100)\n\ndef rhslogistic_model(x,t,r,K):\n\n  rhs=r*x*(1-x/K)\n  return rhs\n\n# Numerically solve the ODE for different parameter values\nsol1=odeint(rhslogistic_model,n_0,t,args=(r_1,K))\nsol2=odeint(rhslogistic_model,n_0,t,args=(r_2,K))\nsol3=odeint(rhslogistic_model,n_0,t,args=(r_3,K))\n\n\n# Plot solutions\nfig, ax = plt.subplots(1)\n\nax.plot(t, sol1,t, sol2,t, sol3)\nplt.xlabel('$t$')\nplt.ylabel('$N$')\nplt.grid(True)\nplt.legend(['r='+str(r_1),'r='+str(r_2),'r='+str(r_3)])\nplt.show()\n\n\n\n\n\n\n\n\nFigure 2.3: Numerical solution of the logistic growth model\n\n\n\n\n\n\n\n2.4.0.2 Dimensional analysis and nondimensionalisation\n\\(N\\) represents the population density and has units of one over area (say \\(1/m^2\\)) and \\(t\\) has units of time (say, seconds, \\(s\\)). Hence the left-hand side of Equation 2.4 has units of \\(1/(m^2 s)\\). The first term on the right-hand side of Equation 2.4 is \\(rN\\). \\(N\\) has units \\(1/m^2\\) hence the parameter \\(r\\) must have units of \\(1/s\\) for dimensional consistency. This is consistent as \\(r\\) represents the linear growth rate.\nThe second term has the form \\(rN^2/K\\). Given the chosen units for \\(r\\) and \\(N\\), the parameter \\(K\\) must have dimensions \\(1/m^2\\). Again, this is consistent as \\(K\\) is a carrying capacity (i.e. it has units of population density).\nWe define the nondimensionalised variables \\[\nn=\\frac{N}{\\tilde{N}} \\ \\ \\ \\ \\ \\ \\tau=\\frac{t}{\\tilde{T}}\n\\] where \\(\\tilde{N}\\) and \\(\\tilde{T}\\) are constants that have units of population density and time, respectively. Hence Equation 2.4 transforms, upon change of variables, to \\[\n\\begin{aligned}\n\\frac{\\tilde{N}}{\\tilde{T} }\\frac{dn}{d\\tau}=r\\tilde{N}n(1-\\frac{n\\tilde{N}}{K}).\n\\end{aligned}\n\\]\nIn the case of the logistic equation there is only one time scale and density scale in the problem, hence we choose \\[\n\\tilde{T}=\\frac{1}{r}  \\ \\ \\ and \\ \\ \\ \\tilde{N}=K\n\\] and the dimensionless model is \\[\n\\begin{aligned}\n\\frac{dn}{d\\tau}= n(1-n)\n\\end{aligned}\n\\tag{2.5}\\] Note that we can retrieve the original equation by rescaling and calculating \\(N=\\tilde{N}n\\) and \\(t=\\tilde{T}\\tau\\).\n\n\n2.4.1 Fixed points and linear stability\nFixed points satisfy \\[\nn^*(1-n^*)=0.\n\\] Hence \\[\nn^*=0, \\ \\ \\ \\ n^*=1.\n\\]\nTo determine linear stability we compute \\[\nH'(n)= (1-2n).\n\\] When \\(n=n^*=0\\) we obtain \\[\nH'(n)= 1.\n\\] Hence the origin is a linearly unstable fixed point.\nAt the steady-state \\(n^*=1\\) \\[\nH'(n^*)= -1\n\\] hence \\(n^*=1\\) is linearly stable.\nNote that the linear stability analysis can explain the observations regarding the numeric solutions presented in Figure 2.3.\n\n\n2.4.2 Graphical analysis\nIn Figure 2.4 we plot the right-hand side of Equation 2.5. We can qualitatively describe model solutions by considering the arrow along the \\(n\\) axis. Suppose we consider an initial condition with \\(0&lt;n_0&lt;1\\). Using the graph of \\(H(n)\\), \\(dn/d\\tau\\) is positive, hence \\(n\\) increases as a function of time until \\(n(\\tau)\\rightarrow 1\\).\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nN_max=2.1\nK=2\nr=0.2\nN_vec=np.linspace(0,N_max,100)\n\nrhs=r*N_vec*(1-N_vec/K)\nfig, ax = plt.subplots(1)\n\nax.plot(N_vec, rhs)\nplt.xlabel('$N$')\nplt.ylabel('$H(N)$')\nplt.show()\n\n\n\n\n\n\n\n\nFigure 2.4: Right-hand side of the logistic ODE\n\n\n\n\n\n\nExample 2.6 Use separation of variables to show that the solution can be written explicitly as \\[\nN(t)=\\frac{N_0K e^{rt}}{K+N_0(e^{rt}-1)}\n\\]\n\n\nSolution\\[\n\\int\\frac{ dN}{N(1-\\frac{N}{K})}=r\\int dt.\n\\] Using partial fractions \\[\n\\int\\frac{ dN}{N} + \\frac{1}{K}\\int\\frac{ dN}{1-\\frac{N}{K}}=r\\int dt.\n\\] Integration yields \\[\n\\ln N - \\ln\\left(1-\\frac{N}{K}\\right)= \\ln \\frac{N }{1-\\frac{N}{K}} =  rt+C.\n\\] Hence \\[\nN=\\frac{De^{rt}}{1+\\frac{D}{K}e^{rt}}\n\\] Given an initial condition \\(N(0)=N_0\\), we obtain \\[\nN(t)=\\frac{N_0K e^{rt}}{K+N_0(e^{rt}-1)}\n\\]\n\n\n\n2.4.2.1 Qualitative analysis of the exact solution\nAs \\(t\\rightarrow \\infty\\), \\(N\\rightarrow K\\). At \\(t=0\\), \\(N=N_0\\) and that for small \\(N_0\\ll K\\) the initial growth phase is exponential, i.e.  \\[\nN(t)\\sim N_0 e^{rt} \\\\ \\ \\ \\ \\ N_0\\ll K, t\\ll \\frac{1}{r}.\n\\]",
    "crumbs": [
      "1D flows",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Flows on the line</span>"
    ]
  },
  {
    "objectID": "1DFlows.html#impossibility-of-oscillations",
    "href": "1DFlows.html#impossibility-of-oscillations",
    "title": "2  Flows on the line",
    "section": "2.5 Impossibility of oscillations",
    "text": "2.5 Impossibility of oscillations\nIn 1D flows with well behaved \\(f\\), the range of permissible qualitiative behaviours is limited by the geometry of the line. Solutions must have one of the following behaviours:\n\ntend towards a stable fixed point\nmove away from an unstable fixed point\nstay at a fixed point for all time\ntend to \\(\\pm \\infty\\)\n\nOscillatory solutions to Equation 1.5 are impossible, i.e. first order autonomous ODEs (with one dependent variable) cannot oscillate.\nThis can be argued using geometrical constraints of dynamics on the line.\n\nExample 2.7 Consider the integral \\[\n\\int_t^{t+T} f(x(t))\\frac{dx}{dt}dt,\n\\] where \\(T\\) is the oscillation period. Use proof by contradiction to show that periodic solutions are impossible.\n\n\nSolutionSuppose that a periodic solution exists such that \\[\nx(t+T)=x(t), \\ \\ x(t+s)\\neq x(t+T) \\forall 0&lt;s&lt;T.\n\\]\nConsider \\[\n\\int_t^{t+T} f(x(t))\\frac{dx}{dt}dt.\n\\]\nThis integral can be written as \\[\n\\int_t^{t+T} f(x(t))^2 dt&gt;0,\n\\] as \\(f\\) is not identically zero.\nChanging variables yields \\[\n\\int_{x(t)}^{x(t+T)} f(x) dx =0.\n\\]\nHence there is a contradiction and no periodic solutions exist.",
    "crumbs": [
      "1D flows",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Flows on the line</span>"
    ]
  },
  {
    "objectID": "1DFlows.html#potential-flows",
    "href": "1DFlows.html#potential-flows",
    "title": "2  Flows on the line",
    "section": "2.6 Potential flows",
    "text": "2.6 Potential flows\nConsider the ODE \\[\n\\dot{x}=f(x).\n\\]\nSuppose that \\[\nf(x)=-\\frac{d V(x)}{dx}.\n\\]\nNow consider \\[\n\\dot{V}.\n\\] Applying the chain rule \\[\n\\dot{V}=\\frac{dV}{dx}\\dot{x}=-(\\frac{dV}{dx})^2\\leq 0.\n\\]\nHence for a potential flow \\(V\\) is never increasing. Hence particle move to points of lower potential until they reach equilibrium given by \\[\nf(x)=-\\frac{d V(x)}{dx}=0.\n\\]\n\nExample 2.8 Graph the potential for the system \\[\n\\dot{x}=-x\n\\] and identify equilibrium points.",
    "crumbs": [
      "1D flows",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Flows on the line</span>"
    ]
  },
  {
    "objectID": "Bifurcations.html",
    "href": "Bifurcations.html",
    "title": "3  Bifurcations",
    "section": "",
    "text": "3.1 Introduction\nThe qualitative behaviour of solutions of \\[\n\\dot{x}=f(x), \\quad  x(0)=x_0\n\\]\nare limited. Solutions either flow to a fixed point, remain at a fixed point or tend to \\(\\pm \\infty\\). So what is interesting about the study of such problems?\nNow we introduce the idea of bifurcations. These arise when the structure of the solutions (i.e. the number and/or stability of fixed points) changes at particular parameter values.\nAt a bifurcation point of a 1D system the eigenvalue is 0. Hence the fixed point is not hyperbolic.\nConsider the 1D system \\[\n\\dot{x}=f(x,r)\n\\] where \\(r\\) is a parameter.\nSuppose that\nUpon Taylor expansion of \\(f\\) about \\((x^*,r_c)\\), we obtain \\[\n\\dot{x}=f(x^*,r_c)+\\frac{\\partial f}{\\partial x}_{(x^*,r_c)}(x-x^*) + \\frac{\\partial f}{\\partial r}_{(x^*,r_c)}(r-r_c)\n+ \\frac{1}{2}(x-x_c)^2\\frac{\\partial^2 f}{\\partial x^2}_{(x^*,r_c)}  + ... \\]\nAs \\(x^*\\) is a fixed point\n\\[\n\\dot{x}= \\frac{\\partial f}{\\partial r}_{(x^*,r_c)}(r-r_c)\n+ \\frac{1}{2}(x-x^*)^2\\frac{\\partial^2 f}{\\partial x^2}_{(x^*,r_c)}  +\\frac{1}{2}(r-r_c)^2\\frac{\\partial^2 f}{\\partial r^2}_{(x^*,r_c)} +(r-r_c)(x-x^*)\\frac{\\partial^2 f}{\\partial r \\partial x}_{(x^*,r_c)}  ... \\]\nClose to a bifurcation point, the stability classification will be determined by the higher order derivatives of \\(f\\) w.r.t. \\(x\\) and \\(r\\).\nIt can be shown that bifurcations of the systems \\[\n\\dot{x}=f(x,r), \\quad x(0)=x_0\n\\] can be reduced to one of three normal forms:",
    "crumbs": [
      "1D flows",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Bifurcations</span>"
    ]
  },
  {
    "objectID": "Bifurcations.html#introduction",
    "href": "Bifurcations.html#introduction",
    "title": "3  Bifurcations",
    "section": "",
    "text": "there is a fixed point \\(x=x^*\\).\nat some \\(r=r_c\\) the eigenvalue of the linearised system vanishes.\n\n\n\n\n\n\n\nsaddle node bifurcations\ntranscritical bifurcations\npitchfork bifurcations",
    "crumbs": [
      "1D flows",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Bifurcations</span>"
    ]
  },
  {
    "objectID": "Bifurcations.html#saddle-node",
    "href": "Bifurcations.html#saddle-node",
    "title": "3  Bifurcations",
    "section": "3.2 Saddle node",
    "text": "3.2 Saddle node\nAt a saddle node bifurcation, two fixed points move towards one another and mutually annihilate. The canonical form is given by\n\\[\n\\dot{x}=f(x,r)=r+x^2,\n\\tag{3.1}\\] where \\(r \\in \\Re\\).\n\nExample 3.1 Identify the fixed points of Equation 3.1 and determine their linear stability.\n\n\nSolutionThe fixed points are \\[\nx^*_{\\pm}=\\pm \\sqrt{-r}.\n\\]\nIn the case \\(r&lt;0\\)\n\\[\nf'(x^*)=\\pm 2\\sqrt{-r}.\n\\]\nHence \\(x^*_-\\) is linearly stable and \\(x^*_+\\) is linearly unstable.\nFor \\(r=0\\) the fixed point is half-stable and it vanishes for \\(r&gt;0\\). Upon plotting \\(x^*\\) against \\(r\\) we obtain a bifurcation diagram.\n\n\nIn Figure 3.1 we plot \\(f\\) at three different values of \\(r\\). Note that when \\(r&gt;0\\), \\(f&gt;0\\) and the solution is an increasing function of time.\nAt \\(r=0\\) there is a double root of \\(f\\). Here the fixed point is half stable. For the initial condition \\(x_0&lt;0\\) the solution will increase until \\(x(t=0)\\). It is stable to perturbations along the negative \\(x\\) axis. However, for \\(x_0&gt;0\\) \\(f&gt;0\\) and the solution is an increasing function of time. Hence the solution is unstable to perturbations with \\(x_0&gt;0\\). Hence the fixed point \\(x^*=0\\) is defined to be half-stable when \\(r=0\\).\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nx=np.linspace(-1.5,1.5)\n\nr_vec=[-1.0,0.0,1.0]\nfig,ax=plt.subplots(1,3,sharex=True, sharey=True)\nax=ax.flatten()\n\nfor i,r_i in enumerate(r_vec):\n    f=r_i+x**2\n    ax[i].plot(x,f)\n    r=r_i\n     # ---- fixed points ----\n    fixed_points = []\n    if r &lt;= 0:\n        fixed_points += [np.sqrt(-r), -np.sqrt(-r)]\n    \n    for x_fp in fixed_points:\n        df =  2 * x_fp   # derivative at fixed point\n        \n        if df &lt; 0:   # stable\n            ax[i].plot(x_fp, 0, 'ko', markersize=8)\n        else:        # unstable\n            ax[i].plot(x_fp, 0, 'ko', markerfacecolor='white', markersize=8)\n\n    ax[i].axhline(0, color='gray', lw=0.5)\n    ax[i].axvline(0, color='gray', lw=0.5)\n    ax[i].set_title(f\"r = {r}\")\n    ax[i].set_ylim([-2,2])\n\n    x_arrows = np.linspace(-1.8, 1.8, 6)\n    f_arrows = r+x_arrows**2\n\n    for xa, fa in zip(x_arrows, f_arrows):\n        if abs(fa) &lt; 1e-6:\n            continue\n        direction = np.sign(fa)\n        ax[i].arrow(\n            xa, 0,\n            0.12 * direction, 0,\n            head_width=0.08,\n            head_length=0.16,\n            fc='k', ec='k',\n            length_includes_head=True\n        )\n    fig.supxlabel('$x$')\n    fig.supylabel('$\\dot{x}$')\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 3.1\n\n\n\nIn Figure 3.2 we plot the fixed points against the parameter \\(r\\). For \\(r&lt;0\\) there are two fixed points (\\(\\sqrt{r}\\) is linearly unstable whilst \\(-\\sqrt{r}\\) is linearly stable). Usually some annotation is used to denote the stability. For \\(r&gt;0\\) there are no fixed points.\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nr = np.linspace(-2, 2, 400)\n\n# fixed points\nx0 = np.zeros_like(r)\n\nx_plus = np.full_like(r, np.nan)\nx_minus = np.full_like(r, np.nan)\n\nmask = r &gt; 0\nx_plus[mask] = np.sqrt(r[mask])\nx_minus[mask] = -np.sqrt(r[mask])\n\nfig, ax = plt.subplots(figsize=(6, 5))\n\n# unstable branch x = 0 for r &gt; 0\n\n\n# stable branches ±sqrt(r)\nax.plot(-r, x_plus, 'k--', lw=2)\nax.plot(-r, x_minus, 'k-', lw=2)\n\nax.axhline(0, color='gray', lw=0.5)\nax.axvline(0, color='gray', lw=0.5)\n\nax.set_xlabel(\"$r$\")\nax.set_ylabel(\"$x*$\")\nax.set_xlim([-2,2])\n\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 3.2\n\n\n\nWith the app below you can explore how the value of the parameter value \\(r\\) affects system dynamics.\nThe app computes solutions to \\[\n\\dot{x}=r+x^2, \\quad x(0)=x_0, \\quad t \\in[0,T].\n\\]\n#| '!! shinylive warning !!': |\n#|   shinylive does not work in self-contained HTML documents.\n#|   Please set `embed-resources: false` in your metadata.\n#| standalone: true\n#| viewerHeight: 800\n#| label: fig-saddlenode\n\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\n\napp_ui = ui.page_fluid(\n                 \n    ui.input_slider(id=\"u0\",label=\"x_0 (Init. Cond.)\",min=-1.0,max=1.0,value=0.5,step=0.01),\n    ui.input_slider(id=\"T\",label=\"T (Time)\",min=0.1,max=60.0,value=20.0,step=1.0),\n    ui.input_slider(id=\"r\",label=\"r\",min=-1.0,max=1.0,value=0.1,step=0.01),\n    ui.output_plot(\"plot\"),\n\n)\n\ndef server(input, output, session):\n    @output\n    @render.plot\n    def plot():\n        fig, ax = plt.subplots(3,1,figsize=(12, 4))\n        #ax.set_ylim([-2, 2])\n        #         \n        r=float(input.r())\n        u0=float(input.u0())\n        T=int(input.T())\n\n        if r&gt;0:\n            T=1/np.sqrt(r)*(np.pi/2.0-np.arctan(u0/np.sqrt(r)))\n        elif (r&lt;0):\n            if u0&gt;np.sqrt(-r):\n                T=1/np.sqrt(-r)*(np.pi/2.0-np.arctan(u0/np.sqrt(-r)))\n        else:\n            T=1/u0\n        \n\n        # Define rhs of bfc ODE \n        def saddle_node_bfc_rhs(y,t,r):\n          rhs=r+y**2.0\n          return rhs\n        \n        def ODESol(saddle_node_bfc_rhs,y_0,t,r):\n            y=np.zeros_like(t,dtype=float)\n            init_cond=y_0\n\n            \n            sol1 = odeint(saddle_node_bfc_rhs, init_cond,t,args=(r,))\n            return sol1\n            \n        # Define discretised t domain\n        t = np.linspace(0, T)\n        # define initial conditions\n        init_cond=u0\n        \n        ax[0].set_xlabel('$t$')\n        ax[0].set_ylabel('$x(t)$')\n\n        plt.grid()\n        \n        # Compute numerical solution of ODEs\n        sol1 = ODESol(saddle_node_bfc_rhs,init_cond,t,r)\n\n        # Plot results\n        x=sol1\n        \n        ax[0].plot(t,x)\n        ax[0].set_xlabel('$t$')\n        ax[0].set_ylabel('$x$')\n        ax[0].set_ylim([-3,3])\n        ax[0].set_title('Numerical solution')\n\n        r_values = np.linspace(-2.0, 2.0, 1000)  # range of r values\n        \n        x=np.sqrt(r_values)\n\n        ax[1].plot(-r_values,x,'k--',-r_values,-x,'k')\n        ax[1].set_xlabel('$r$')\n        ax[1].set_ylabel('$x^*$')\n        ax[1].set_xlim([-3,3])\n        ax[1].set_title('Bifurcation diagram')\n        ax[1].plot([r,r],[-3,3],'--')\n\n\n        x_plot=np.linspace(-3,3)\n        f=saddle_node_bfc_rhs(x_plot,0,r)\n        ax[2].plot(x_plot,f)\n        ax[2].set_xlabel('$x$')\n        ax[2].set_ylabel('$f$')\n        ax[2].set_ylim([-2,2])\n        ax[2].plot([u0,u0],[-2,2],'--')\n\n        ax[2].set_title('Phase portrait')\n        \n\n\n        \napp = App(app_ui, server)\nAn app to exploring behaviour of the saddle-node bifurcation.\n\nExample 3.2 Consider the following ODE: \\[\n\\dot{x}=1+rx+x^2, \\quad x(0)=x_0.\n\\] in the case \\(r \\in \\Re^+\\).\n\nSketch the bifurcation diagram.\nShow that upon introducing rescaled variables, the ODE can be written in the normal form \\[\n\\dot{y}=r'+y^2.\n\\] Hint: try completing the square.",
    "crumbs": [
      "1D flows",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Bifurcations</span>"
    ]
  },
  {
    "objectID": "Bifurcations.html#transcritical",
    "href": "Bifurcations.html#transcritical",
    "title": "3  Bifurcations",
    "section": "3.3 Transcritical",
    "text": "3.3 Transcritical\nAt a transcritical bifurcation the stability of a fixed point changes as a parameter is varied. However, fixed points do not disappear, as was the case with the saddle node bifurcation.\nThe normal form for a transcritical bifurcation is\n\\[\n\\dot{x}=rx-x^2,\n\\]\n\nExample 3.3 Identify the fixed points and their linear stability\n\n\nSolutionThe fixed points are \\(x^*=0\\) and \\(x^*=r\\). For \\(r&lt;0\\), \\(x^*=r\\) is linearly unstable and \\(x^*=0\\) is linearly stable. At \\(r=0\\) the fixed points coalesce and the fixed point is half stable. For \\(r&gt;0\\) \\(x^*=0\\) is linearly unstable and \\(x^*=r\\) is linearly stable.\n\n\nIn Figure 3.3 the function \\(f\\) is plotted for different values of the parameter \\(r\\). The origin is always a fixed point. For \\(r&lt;0\\) there is a fixed point on the negative real axis whilst for \\(r&gt;0\\) there is a fixed point on the positive real axis. Hence the number of fixed points is two for \\(|r|&gt;0\\). This bifurcation is fundamentally different to the saddle node bifurcation (where there are no fixed points on one side of the bifurcation).\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nx=np.linspace(-1.5,1.5)\n\nr_vec=[-1.0,0.0,1.0]\nfig,ax=plt.subplots(1,3,sharex=True, sharey=True)\nax=ax.flatten()\n\nfor i,r_i in enumerate(r_vec):\n    f=r_i*x-x**2\n    ax[i].plot(x,f)\n    r=r_i\n     # ---- fixed points ----\n    fixed_points = [0.0]\n    if r &gt; 0:\n        fixed_points += [0,r]\n    elif r&lt;0:\n        fixed_points += [r,0]\n\n    \n    for x_fp in fixed_points:\n        df = r - 2 * x_fp   # derivative at fixed point\n        \n        if df &lt; 0:   # stable\n            ax[i].plot(x_fp, 0, 'ko', markersize=8)\n        else:        # unstable\n            ax[i].plot(x_fp, 0, 'ko', markerfacecolor='white', markersize=8)\n\n    ax[i].axhline(0, color='gray', lw=0.5)\n    ax[i].axvline(0, color='gray', lw=0.5)\n    ax[i].set_title(f\"r = {r}\")\n    ax[i].set_ylim([-2,2])\n\n    x_arrows = np.linspace(-1.8, 1.8, 6)\n    f_arrows = r * x_arrows - x_arrows**2\n\n    for xa, fa in zip(x_arrows, f_arrows):\n        if abs(fa) &lt; 1e-3:\n            continue\n        direction = np.sign(fa)\n        ax[i].arrow(\n            xa, 0,\n            0.12 * direction, 0,\n            head_width=0.08,\n            head_length=0.08,\n            fc='k', ec='k',\n            length_includes_head=True\n        )\n    fig.supxlabel('$x$')\n    fig.supylabel('$\\dot{x}$')\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 3.3\n\n\n\nIn Figure 3.4 we plot a bifurcation diagram for the transcritical bifurcation. Note that \\(x^*=0\\) is always a fixed points but it’s stability changes at \\(r=0\\).\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nr = np.linspace(-2, 2, 400)\n\n# fixed points\nx0 = np.zeros_like(r)\n\nx_plus = np.full_like(r, np.nan)\nx_minus = np.full_like(r, np.nan)\n\nmask = r &gt;= 0\nx_plus[mask] = (r[mask])\nx_minus[mask] = (r[mask])\n\nfig, ax = plt.subplots(figsize=(6, 5))\n\n# unstable branch x = 0 for r &gt; 0\nax.plot(r[r &gt; 0], x0[r &gt; 0], 'k--', lw=2)\nax.plot(r[r &lt; 0], r[r &lt; 0], 'k--', lw=2)\n\n# stable branch x = 0 for r &lt; 0\nax.plot(r[r &lt; 0], x0[r &lt; 0], 'k-', lw=2)\n\n# stable branches ±sqrt(r)\nax.plot(r, x_plus, 'k-', lw=2)\nax.plot(r, x_minus, 'k-', lw=2)\n\nax.axhline(0, color='gray', lw=0.5)\nax.axvline(0, color='gray', lw=0.5)\n\nax.set_xlabel(\"$r$\")\nax.set_ylabel(\"$x*$\")\n\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 3.4\n\n\n\nWith the app below you can explore how the value of the parameter value \\(r\\) affects system dynamics for the transcritical bifurcation.\nThe app computes solutions to \\[\n\\dot{x}=rx-x^2, \\quad x(0)=x_0, \\quad t \\in[0,T].\n\\]\n#| '!! shinylive warning !!': |\n#|   shinylive does not work in self-contained HTML documents.\n#|   Please set `embed-resources: false` in your metadata.\n#| standalone: true\n#| viewerHeight: 800\n#| label: fig-transcrit\n\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\nfrom scipy.integrate import solve_ivp\n\napp_ui = ui.page_fluid(\n                 \n    ui.input_slider(id=\"u0\",label=\"x_0 (Init. Cond.)\",min=-3.0,max=3.0,value=0.5,step=0.01),\n    ui.input_slider(id=\"T\",label=\"T (Time)\",min=0.1,max=60.0,value=20.0,step=1.0),\n    ui.input_slider(id=\"r\",label=\"r\",min=-2.0,max=2.0,value=0.1,step=0.1),\n    ui.output_plot(\"plot\"),\n\n)\n\ndef server(input, output, session):\n    @output\n    @render.plot\n    def plot():\n        fig, ax = plt.subplots(3,1,figsize=(12, 4))\n        #ax.set_ylim([-2, 2])\n        #         \n        r=float(input.r())\n        u0=float(input.u0())\n        T=int(input.T())\n    \n        \n        # Define rhs of bfc ODE \n        def saddle_node_bfc_rhs(t,y,r):\n          rhs=r*y-y**2\n          return rhs\n        def stop_event(t, y,r):\n            return np.abs(y[0]-10)          # trigger when y[0] == 0\n\n        \n        def ODESol(saddle_node_bfc_rhs,y_0,T,r):\n            #y=np.zeros_like(t,dtype=float)\n            init_cond=y_0\n\n            stop_event.terminal = True   # STOP integration\n            stop_event.direction = 1   # only trigger when crossing downward\n\n            sol1 = solve_ivp(saddle_node_bfc_rhs,t_span=(0, T),y0=[init_cond],\n                events=stop_event,args=(r,)\n            )\n            return sol1\n            \n        # Define discretised t domain\n        # define initial conditions\n        init_cond=u0\n        \n        ax[0].set_xlabel('$t$')\n        ax[0].set_ylabel('$x(t)$')\n\n        plt.grid()\n        \n        # Compute numerical solution of ODEs\n        sol1 = ODESol(saddle_node_bfc_rhs,init_cond,T,r)\n        \n        ax[0].plot(sol1.t,sol1.y[0])\n        ax[0].set_xlabel('$t$')\n        ax[0].set_ylabel('$x$')\n        ax[0].set_ylim([-10,10])\n        ax[0].set_title('Numerical solution')\n\n        \n        r_values = np.linspace(-2.0, 2.0, 1000)  # range of r values\n        \n        x_1=np.zeros_like(r_values)\n        x_2=r_values\n\n        ax[1].plot(r_values[r_values&lt;0],x_1[r_values&lt;0],'k',r_values[r_values&lt;0],x_2[r_values&lt;0],'k--')\n        ax[1].plot(r_values[r_values&gt;0],x_1[r_values&gt;0],'k--',r_values[r_values&gt;0],x_2[r_values&gt;0],'k')\n        ax[1].set_xlabel('$r$')\n        ax[1].set_ylabel('$x^*$')\n        ax[1].set_xlim([-3,3])\n        ax[1].set_title('Bifurcation diagram')\n        ax[1].plot([r,r],[-3,3],'--')\n\n        \n        x_plot=np.linspace(-3,3)\n        f=saddle_node_bfc_rhs(0,x_plot,r)\n        ax[2].plot(x_plot,f)\n        ax[2].set_xlabel('$x$')\n        ax[2].set_ylabel('$f$')\n        ax[2].set_ylim([-2,2])\n        ax[2].plot([u0,u0],[-2,2],'--')\n\n        ax[2].set_title('Phase portrait')\n\n        x_arrows = np.linspace(-1.8, 1.8, 6)\n        f_arrows = r * x_arrows - x_arrows**2\n\n        for xa, fa in zip(x_arrows, f_arrows):\n            if abs(fa) &lt; 1e-3:\n                continue\n            direction = np.sign(fa)\n            ax[2].arrow(\n                xa, 0,\n                0.12 * direction, 0,\n                head_width=0.2,\n                head_length=0.28,\n                fc='k', ec='k',\n                length_includes_head=True\n            )\n        \n                \napp = App(app_ui, server)\nAn app for exploring behaviour of the transcritical bifurcation.\n\n\nExample 3.4 Sketch the bifurcation diagram for\n\\[\n\\dot{x}=rx+x^2.\n\\]\n\n\nExample 3.5 Consider the ODE\n\\[\n\\dot{x}=r\\ln x + x-1.\n\\]\n\nShow that \\(x^*=1\\) is a fixed point.\nMake a change of variables \\(u=x-1\\) in order to analyse perturbations about the fixed point.\nUse a Taylor expansion to show that this system can be approximated by the transcritical normal form. Hence deduce that the bifurcation vaue is \\(r=-1\\).\nShow that the system can be reduced to the normal form \\[\n\\dot{X}=RX-X^2\n\\] by making an appropriate change of variables.",
    "crumbs": [
      "1D flows",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Bifurcations</span>"
    ]
  },
  {
    "objectID": "Bifurcations.html#pitchfork",
    "href": "Bifurcations.html#pitchfork",
    "title": "3  Bifurcations",
    "section": "3.4 Pitchfork",
    "text": "3.4 Pitchfork\nPitchfork bifurcations often arise in situations with symmetry. Typically, two or more fixed points appear/disappear together.\n\n3.4.1 Supercritical pitchfork\nThe normal form of the supercritical pitchfork bifurcation is \\[\n\\dot{x}=rx-x^3,\n\\]\n\nExample 3.6 Identify the fixed points and determine their linear stability\n\n\nSolutionThe fixed points satisfy \\[\nrx^*-{x^*}^3=0\n\\]\nHence \\(x^*\\) is a fixed point. Other fixed points satisfy \\[\nr-{x^*}^2=0\n\\]\nHence there is a pair of fixed points given by \\[\nx^*= \\pm \\sqrt{r},\n\\] defined for \\(r&gt;0\\).\nFor \\[\nf(x,r)=rx-x^3\n\\] differentiation yields \\[\nf'(x)=r-3x^2.\n\\]\nAt \\(x^*=0\\)\n\\[\nf'(0)=r.\n\\]\nFor \\(r&lt;0\\), \\(x^*=0\\) is linearly stable. For \\(r&gt;0\\), \\(x^*=0\\) is linearly unstable. There is a bifurcation at \\(r=0\\).\nAt \\(x^*= \\pm \\sqrt{r}\\)\n\\[\nf'(\\pm \\sqrt{r})=r-3r=-2r.\n\\]\nHence when real, non-trivial fixed points exist \\(r&gt;0\\) they are linearly stable.\nAt \\(r=0\\) the fixed points coalesce and the fixed point is half stable.\n\n\nIn Figure 3.5 we plot \\(f\\) for three different values of \\(r\\). For \\(r&lt;0\\) it is clear that \\(x^*=0\\) is a uniquye fixed point and that it is linearly stable. For \\(r&gt;0\\) \\(f\\) is a cubic with three real roots. Note that the non-zero roots are linearly stable and symmetrically distributed about the origin. We refer to a system with two linearly stable fixd points as being bistable.\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nx=np.linspace(-1.5,1.5)\n\nr_vec=[-1.0,0.0,1.0]\nfig,ax=plt.subplots(1,3,sharex=True, sharey=True)\nax=ax.flatten()\n\nfor i,r_i in enumerate(r_vec):\n    f=r_i*x-x**3\n    ax[i].plot(x,f)\n    r=r_i\n     # ---- fixed points ----\n    fixed_points = [0.0]\n    if r &gt; 0:\n        fixed_points += [np.sqrt(r), -np.sqrt(r)]\n    \n    for x_fp in fixed_points:\n        df = r - 3 * x_fp**2   # derivative at fixed point\n        \n        if df &lt; 0:   # stable\n            ax[i].plot(x_fp, 0, 'ko', markersize=8)\n        else:        # unstable\n            ax[i].plot(x_fp, 0, 'ko', markerfacecolor='white', markersize=8)\n\n    ax[i].axhline(0, color='gray', lw=0.5)\n    ax[i].axvline(0, color='gray', lw=0.5)\n    ax[i].set_title(f\"r = {r}\")\n    ax[i].set_ylim([-2,2])\n\n    x_arrows = np.linspace(-1.8, 1.8, 6)\n    f_arrows = r * x_arrows - x_arrows**3\n\n    for xa, fa in zip(x_arrows, f_arrows):\n        if abs(fa) &lt; 1e-3:\n            continue\n        direction = np.sign(fa)\n        ax[i].arrow(\n            xa, 0,\n            0.12 * direction, 0,\n            head_width=0.08,\n            head_length=0.08,\n            fc='k', ec='k',\n            length_includes_head=True\n        )\n    fig.supxlabel('$x$')\n    fig.supylabel('$\\dot{x}$')\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 3.5\n\n\n\nIn Figure 3.6 we plot a bifurcation diagram for the supercritical pitchfork. Note that when \\(r&lt;0\\) there is a single fixed point that is linearly stable. For \\(r&gt;0\\) there are three fixed points.\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nr = np.linspace(-2, 2, 400)\n\n# fixed points\nx0 = np.zeros_like(r)\n\nx_plus = np.full_like(r, np.nan)\nx_minus = np.full_like(r, np.nan)\n\nmask = r &gt;= 0\nx_plus[mask] = np.sqrt(r[mask])\nx_minus[mask] = -np.sqrt(r[mask])\n\nfig, ax = plt.subplots(figsize=(6, 5))\n\n# unstable branch x = 0 for r &gt; 0\nax.plot(r[r &gt; 0], x0[r &gt; 0], 'k--', lw=2)\n\n# stable branch x = 0 for r &lt; 0\nax.plot(r[r &lt; 0], x0[r &lt; 0], 'k-', lw=2)\n\n# stable branches ±sqrt(r)\nax.plot(r, x_plus, 'k-', lw=2)\nax.plot(r, x_minus, 'k-', lw=2)\n\nax.axhline(0, color='gray', lw=0.5)\nax.axvline(0, color='gray', lw=0.5)\n\nax.set_xlabel(\"$r$\")\nax.set_ylabel(\"$x*$\")\n\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 3.6\n\n\n\nWith the app below you can explore how the value of the parameter value \\(r\\) affects system dynamics for the supercritical pitchfork bifurcation.\nThe app computes solutions to \\[\n\\dot{x}=rx-x^3, \\quad x(0)=x_0, \\quad t \\in[0,T].\n\\]\n\nShow that in the case where \\(r&gt;0\\) the initial conditions control which of the stable fixed points the system finds.\n\n#| '!! shinylive warning !!': |\n#|   shinylive does not work in self-contained HTML documents.\n#|   Please set `embed-resources: false` in your metadata.\n#| standalone: true\n#| viewerHeight: 800\n#| label: fig-transcrit\n\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\nfrom scipy.integrate import solve_ivp\n\napp_ui = ui.page_fluid(\n                 \n    ui.input_slider(id=\"u0\",label=\"x_0 (Init. Cond.)\",min=-3.0,max=3.0,value=0.5,step=0.01),\n    ui.input_slider(id=\"T\",label=\"T (Time)\",min=0.1,max=60.0,value=20.0,step=1.0),\n    ui.input_slider(id=\"r\",label=\"r\",min=-2.0,max=2.0,value=0.1,step=0.1),\n    ui.output_plot(\"plot\"),\n\n)\n\ndef server(input, output, session):\n    @output\n    @render.plot\n    def plot():\n        fig, ax = plt.subplots(3,1,figsize=(12, 4))\n        #ax.set_ylim([-2, 2])\n        #         \n        r=float(input.r())\n        u0=float(input.u0())\n        T=int(input.T())\n    \n        \n        # Define rhs of bfc ODE \n        def super_pitchfork_bfc_rhs(t,y,r):\n          rhs=r*y-y**3\n          return rhs\n        def stop_event(t, y,r):\n            return np.abs(y[0]-10)          # trigger when y[0] == 0\n\n        \n        def ODESol(rhs,y_0,T,r):\n            #y=np.zeros_like(t,dtype=float)\n            init_cond=y_0\n\n            stop_event.terminal = True   # STOP integration\n            stop_event.direction = 1   # only trigger when crossing downward\n\n            sol1 = solve_ivp(rhs,t_span=(0, T),y0=[init_cond],\n                events=stop_event,args=(r,)\n            )\n            return sol1\n            \n        # Define discretised t domain\n        # define initial conditions\n        init_cond=u0\n        \n        ax[0].set_xlabel('$t$')\n        ax[0].set_ylabel('$x(t)$')\n\n        plt.grid()\n        \n        # Compute numerical solution of ODEs\n        sol1 = ODESol(super_pitchfork_bfc_rhs,init_cond,T,r)\n        \n        ax[0].plot(sol1.t,sol1.y[0])\n        ax[0].set_xlabel('$t$')\n        ax[0].set_ylabel('$x$')\n        ax[0].set_ylim([-2.5,2.5])\n        ax[0].set_title('Numerical solution')\n\n        \n        r_values = np.linspace(-2.0, 2.0, 1000)  # range of r values\n        r_values2 = np.linspace(0.0, 2.0, 1000)  # range of r values\n\n        \n        x_1=np.zeros_like(r_values)\n        x_2=np.sqrt(r_values2)\n\n        ax[1].plot(r_values,x_1,'k')\n\n        ax[1].plot(r_values2,x_2,'k--',r_values2,-x_2,'k--')\n\n        ax[1].set_xlabel('$r$')\n        ax[1].set_ylabel('$x^*$')\n        ax[1].set_xlim([-3,3])\n        ax[1].set_title('Bifurcation diagram')\n        ax[1].plot([r,r],[-3,3],'--')\n\n        \n        x_plot=np.linspace(-3,3)\n        f=super_pitchfork_bfc_rhs(0,x_plot,r)\n        ax[2].plot(x_plot,f)\n        ax[2].set_xlabel('$x$')\n        ax[2].set_ylabel('$f$')\n        ax[2].set_ylim([-2,2])\n        ax[2].plot([u0,u0],[-2,2],'--')\n\n        ax[2].set_title('Phase portrait')\n\n        x_arrows = np.linspace(-1.8, 1.8, 6)\n        f_arrows = r * x_arrows - x_arrows**3\n\n        for xa, fa in zip(x_arrows, f_arrows):\n            if abs(fa) &lt; 1e-3:\n                continue\n            direction = np.sign(fa)\n            ax[2].arrow(\n                xa, 0,\n                0.12 * direction, 0,\n                head_width=0.2,\n                head_length=0.28,\n                fc='k', ec='k',\n                length_includes_head=True\n            )\n        \n                \napp = App(app_ui, server)\nAn app for exploring behaviour of the supercritical pitchfork bifurcation.\n\n\n3.4.2 Subcritical pitchfork\n\\[\n\\dot{x}=rx+x^3,\n\\]\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nx=np.linspace(-1.5,1.5)\n\nr_vec=[-1.0,0.0,1.0]\nfig,ax=plt.subplots(1,3,sharex=True, sharey=True)\nax=ax.flatten()\n\nfor i,r_i in enumerate(r_vec):\n    f=r_i*x+x**3\n    ax[i].plot(x,f)\n    r=r_i\n     # ---- fixed points ----\n    fixed_points = [0.0]\n    if r &lt; 0:\n        fixed_points += [np.sqrt(-r), -np.sqrt(-r)]\n    \n    for x_fp in fixed_points:\n        df = r + 3 * x_fp**2   # derivative at fixed point\n        \n        if df &lt; 0:   # stable\n            ax[i].plot(x_fp, 0, 'ko', markersize=8)\n        else:        # unstable\n            ax[i].plot(x_fp, 0, 'ko', markerfacecolor='white', markersize=8)\n\n    ax[i].axhline(0, color='gray', lw=0.5)\n    ax[i].axvline(0, color='gray', lw=0.5)\n    ax[i].set_title(f\"r = {r}\")\n    ax[i].set_ylim([-2,2])\n\n    x_arrows = np.linspace(-1.8, 1.8, 6)\n    f_arrows = r * x_arrows + x_arrows**3\n\n    for xa, fa in zip(x_arrows, f_arrows):\n        if abs(fa) &lt; 1e-3:\n            continue\n        direction = np.sign(fa)\n        ax[i].arrow(\n            xa, 0,\n            0.12 * direction, 0,\n            head_width=0.08,\n            head_length=0.08,\n            fc='k', ec='k',\n            length_includes_head=True\n        )\n    fig.supxlabel('$x$')\n    fig.supylabel('$\\dot{x}$')\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 3.7\n\n\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nr = np.linspace(-2, 2, 400)\n\n# fixed points\nx0 = np.zeros_like(r)\n\nx_plus = np.full_like(r, np.nan)\nx_minus = np.full_like(r, np.nan)\n\nmask = -r &gt;= 0\nx_plus[mask] = np.sqrt(-r[mask])\nx_minus[mask] = -np.sqrt(-r[mask])\n\nfig, ax = plt.subplots(figsize=(6, 5))\n\n# unstable branch x = 0 for r &gt; 0\nax.plot(r[r &gt; 0], x0[r &gt; 0], 'k--', lw=2)\n\n# stable branch x = 0 for r &lt; 0\nax.plot(r[r &lt; 0], x0[r &lt; 0], 'k-', lw=2)\n\n# stable branches ±sqrt(r)\nax.plot(r, x_plus, 'k--', lw=2)\nax.plot(r, x_minus, 'k--', lw=2)\n\nax.axhline(0, color='gray', lw=0.5)\nax.axvline(0, color='gray', lw=0.5)\n\nax.set_xlabel(\"$r$\")\nax.set_ylabel(\"$x*$\")\n\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 3.8",
    "crumbs": [
      "1D flows",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Bifurcations</span>"
    ]
  },
  {
    "objectID": "PythonAppendix.html",
    "href": "PythonAppendix.html",
    "title": "4  Python",
    "section": "",
    "text": "4.1 Symbolic calculations\nSymbolic calculations ahve been performed using the Python library Sympy.\nThis library comes with tutorials.\nYou are encouraged to familiarise yourself with the syntax by working through some of the tutorial examples provided at the links above.\nMany of the calculations that we do throughout the course involve solving systems of algebraic equations",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Python</span>"
    ]
  },
  {
    "objectID": "PythonAppendix.html#numerical-solution-of-difference-equations",
    "href": "PythonAppendix.html#numerical-solution-of-difference-equations",
    "title": "4  Python",
    "section": "4.2 Numerical solution of difference equations",
    "text": "4.2 Numerical solution of difference equations\nDifference equations have been solved using a for loop. Routinse have been written to solve either single or coupled system of difference equaitons.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Python</span>"
    ]
  },
  {
    "objectID": "PythonAppendix.html#numerical-integration-of-odes",
    "href": "PythonAppendix.html#numerical-integration-of-odes",
    "title": "4  Python",
    "section": "4.3 Numerical integration of ODEs",
    "text": "4.3 Numerical integration of ODEs\nThroughout the notes systems of ODEs have been integrated using the Scipy function odeint.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Python</span>"
    ]
  },
  {
    "objectID": "PythonAppendix.html#plotting",
    "href": "PythonAppendix.html#plotting",
    "title": "4  Python",
    "section": "4.4 Plotting",
    "text": "4.4 Plotting\nLine graphs are plotted using the Python library Matplotlib.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>Python</span>"
    ]
  }
]