[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "MA32011",
    "section": "",
    "text": "Preface\nWelcome to the module MA32011 Dynamical systems.\nMy name is Philip Murray and I am the module lead.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#how-to-contact-me",
    "href": "index.html#how-to-contact-me",
    "title": "MA32011",
    "section": "How to contact me?",
    "text": "How to contact me?\n\nemail: pmurray@dundee.ac.uk\noffice: G11, Fulton Building\nTeams: PM me",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#lecture-notes",
    "href": "index.html#lecture-notes",
    "title": "MA32011",
    "section": "Lecture notes",
    "text": "Lecture notes\nYou can find lecture notes for the module on this page. If you would like a pdf this can be easily generated by clicking on the pdf link of the webpage. I will occasionally edit/update the notes as we proceed through lectures. If you spot any errors, typos or omissions please let me know.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#reading",
    "href": "index.html#reading",
    "title": "MA32011",
    "section": "Reading",
    "text": "Reading\nNonlinear dynamics and chaos, Steven Strogatz Strogatz (2001) Mathematical Biology I, Murray (2002)",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#python-codes",
    "href": "index.html#python-codes",
    "title": "MA32011",
    "section": "Python codes",
    "text": "Python codes\nI have provided Python codes for most of the figures in the notes (you can unfold code section by clicking `Code’). Note that the Python code does not appear in the pdf.\nMany of you have taken the Introduction to Programming module at Level 2 and have therefore some experience using Python. I strongly encourage you to use the provided codes as a tool to play around with numerical solutions of the various models that we will be working on. The codes should run as standalone Python codes.\n\n\n\n\n\n\nNote\n\n\n\nTo access Python on Uni machines:\n\nLaunch Anaconda from AppsAnywhere\nWhen a folder opens, double click on Spyder.\nPaste a code from lecture notes into the editor on the left-hand side.\nClick on the green arrow to run the code.\nThe plots should appear in the plots tab on the right-hand side.\nExperiment with the code. When you change a model parameter, does the solution change in an expected way?\n\n\n\nI have also provided some examples of how to use Python as a symbolic calculator. This uses a Python library called sympy and is quite similar to Maple.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#assessment",
    "href": "index.html#assessment",
    "title": "MA32011",
    "section": "Assessment",
    "text": "Assessment\n\nFinal exam (80 %)\n2 class tests (8 % each), Week 7 and 11\n4 quizes (1 % each), Week 2,4,6 and 9",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#plan",
    "href": "index.html#plan",
    "title": "MA32011",
    "section": "Plan",
    "text": "Plan\n\nProjected delivery\n\n\nWeek\nUp to Section\nTutorial sheet\nAssessment\n\n\n\n\n1\n\n1\n\n\n\n2\n\n1\nQuiz 1\n\n\n3\n\n2\n\n\n\n4\n\n2\nQuiz 2\n\n\n5\n\n3\n\n\n\n6\n\n3\nQuiz 3\n\n\n7\n\n4\nTest 1\n\n\n8\n\n4\n\n\n\n9\n\n5\nQuiz 4 4\n\n\n10\n\n5\n\n\n\n11\n\nTest 2",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "index.html#references",
    "href": "index.html#references",
    "title": "MA32011",
    "section": "References",
    "text": "References\n\n\n\n\nMurray, J. D. 2002. Mathematical Biology i: An Introduction. Springer.\n\n\nStrogatz, Steven H. 2001. Nonlinear Dynamics and Chaos: With Applications to Physics, Biology, Chemistry, and Engineering (Studies in Nonlinearity). Vol. 1. Westview press.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introduction",
    "section": "",
    "text": "1.1 Discrete v continuous time\nThe goal of this module is to provide an introduction to dynamical systems. We will introduce key mathematical concepts and explore examples from physics and biology.\nTo begin with we introduce some key terminology.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "intro.html#discrete-v-continuous-time",
    "href": "intro.html#discrete-v-continuous-time",
    "title": "1  Introduction",
    "section": "1.2 Autonomous v nonautonomous ODEs",
    "text": "1.1.1 Differential equations\nLet \\(t\\) be a continuous variable and \\(x=x(t)\\). \\(\\dot{x}\\) is used to denote the time derivative, i.e. \\[\n\\dot{x}:=\\frac{dx}{dt}.\n\\]\nSimilarly, the second order derivative is represented by \\[\n\\ddot{x}:=\\frac{d^2x}{dt^2}.\n\\]\n\n1.1.1.1 Population dynamics\nMany of the biological examples that we will encounter later describe population dynamics. Let \\(N(t)\\) represent the size of a population at time \\(t\\).\nSuppose that individuals are born at per capita constant rate \\(b\\) and die at a rate \\(d\\).\nWe can write \\[\nN(t+\\Delta t)=N(t)+bN(t)\\Delta t -dN(t)\\Delta t\n\\]\nGathering terms and taking the limit \\(\\Delta t \\rightarrow 0\\) yields \\[\n\\dot{N}=(b-d)N.\n\\]\nIf we allow the birth and death rates to depend on population size then we can derive a more general equation \\[\n\\dot{N}=H(N),\n\\] where \\(H\\) is some prescribed function. An example is the logistic growth equation \\[\n\\dot{N}=rN(1-N).\n\\tag{1.1}\\]\n\n\n1.1.1.2 Newton’s second law\nMany of the physics examples that we will examine later originate from Newton’s Second Law, i.e.\n\\[\nm\\ddot{x}=F(x,\\dot{x})\n\\] where \\(x(t)\\) represents the position of a particle at time, \\(t\\), \\(m\\) represents a constant particle mass and \\(F\\) a resultant force.\nConsider the case in which \\(F\\) represents a linear restoring force, i.e. \\[\nF(x,\\dot{x})=-kx.\n\\] The equation of motion can be written as \\[\n\\ddot{x}=-\\mu x,\n\\tag{1.2}\\] where \\(\\mu=-k/m\\).\n\nExample 1.6 The app in Figure 1.1 encodes a numerical solution of the second order ODE\n\\[\na\\ddot{x}+b\\dot{x}+cx=0.\n\\]\nUse the app to:\n\nidentify appropriate values of the parameters \\(a\\), \\(b\\) and \\(c\\) so that the solution captures the case of a particle of mass (\\(m\\)) equal to 3 subjected to a linear restoring force with spring constant (\\(k\\)) equal to 5.\nexplore the dependence of oscillation period on initial conditions.\n\nIs the behaviour of the numerical solution consistent with Equation 1.2.\n\n\n#| '!! shinylive warning !!': |\n#|   shinylive does not work in self-contained HTML documents.\n#|   Please set `embed-resources: false` in your metadata.\n#| standalone: true\n#| components: [viewer]\n#| viewerHeight: 800\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\n\napp_ui = ui.page_fluid(\n    ui.input_slider(id=\"a\",label=\"a\",min=0.01,max=3,value=0.1,step=0.001),\n    ui.input_slider(id=\"b\",label=\"b\",min=0.0,max=15.0,value=10.0,step=0.1),             \n    ui.input_slider(id=\"c\",label=\"c\",min=0.0,max=30.0,value=5.0,step=1.0),   \n    ui.input_slider(id=\"y0\",label=\"x(t=0)\",min=0.0,max=20.0,value=5.0,step=1.0),\n    ui.input_slider(id=\"y0p\",label=\"dx/dt(t=0)\",min=0.0,max=20.0,value=1,step=1.0),\n    ui.input_slider(id=\"T\",label=\"Simulation time\",min=0.0,max=60.0,value=20.0,step=0.5),\n        ui.output_plot(\"plot\"),\n)\n\ndef server(input, output, session):\n    \n    @render.plot\n    def plot():\n        fig, ax = plt.subplots()\n        #ax.set_ylim([-2, 2])\n        # Filter fata\n        \n        \n        a=float(input.a())\n        b=float(input.b())\n        c=float(input.c())\n        y_0=float(input.y0())\n        y_0_p=float(input.y0p())\n        T=float(input.T())\n        \n\n        \n        # Define rhs of LV ODEs\n        def rhs_pop_model(y,t,a,b,c):\n          rhs=np.zeros_like(y,dtype=float)\n\n          z=y[1]\n\n          #ay'' + by'+cy=0\n          # y'=z\n          # z'=y''=-(by'+cy)/a\n\n\n          dy_dt=y[1]\n          dz_dt=-(b*z+c*y[0])/a\n\n          rhs[0]=dy_dt\n          rhs[1]=dz_dt\n\n          return rhs\n\n        # Define discretised t domain\n        t = np.linspace(0, T, 1000)\n\n        # define initial conditions\n        init_cond=[y_0,y_0_p]\n        \n        # Compute numerical solution of ODEs\n        sol1 = odeint(rhs_pop_model, init_cond,t,args=(a,b,c))\n\n        # Plot results\n        y=sol1[:,0]\n        yp=sol1[:,1]\n        \n        \n        ax.plot(t, y)\n        ax.set_xlabel('$t$')\n        ax.set_ylabel('$x(t)$')\n\n        plt.grid()\n        #plt.show()\n    \napp = App(app_ui, server)\n\n\nFigure 1.1: Exploring numerical solutions of a linear second order ODE.\n\n\n\n1.1.2 Difference equations\nSuppose that \\(n\\) is a discrete variable. Let \\(y_n\\) represent a dependent variable at iteration \\(n\\). Consider the difference equation \\[\ny_{n+1}=ry_n(1-y_n),\n\\] where \\(r\\in \\Re\\).\n\nExample 1.1 Use the app below to 1. explore how the solution behaviour (top row) changes qualitatively as the parameter \\(r\\) increases. 2. connect the branching structure in the bifurcation diagram (second and third rows) to the qualitative behaviour of the solution (top row). 3. demonstrate self similarity (by zooming in on the bifurcation diagram (bottom row) show that the structure appears to repeat at finer scales).\n\n\n\n#| '!! shinylive warning !!': |\n#|   shinylive does not work in self-contained HTML documents.\n#|   Please set `embed-resources: false` in your metadata.\n#| standalone: true\n#| viewerHeight: 800\n\n\n\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\n\napp_ui = ui.page_fluid(\n                 \n    ui.input_slider(id=\"u0\",label=\"u_0\",min=0.0,max=1.0,value=0.5,step=0.01),\n    ui.input_slider(id=\"T\",label=\"Number of iterations\",min=0.0,max=60.0,value=20.0,step=1.0),\n    ui.input_slider(id=\"r_range\",label=\"r zoomed\",min=0.0,max=4.0,value=[0.0,4.0],step=0.001),\n    ui.input_slider(id=\"u_range\",label=\"u zoomed\",min=0.0,max=1.0,value=[0.0,1.0],step=0.01),ui.output_plot(\"plot\"),\n    ui.input_slider(id=\"r\",label=\"r\",min=0.0,max=5.0,value=0.1,step=0.001),\n)\n\ndef server(input, output, session):\n    @output\n    @render.plot\n    def plot():\n        fig, ax = plt.subplots(3,1,figsize=(12, 4))\n        #ax.set_ylim([-2, 2])\n        # Filter fata\n        \n        \n        r=float(input.r())\n        u0=float(input.u0())\n        T=int(input.T())\n        r_min=float(input.r_range()[0])\n        r_max=float(input.r_range()[1])\n        u_min=float(input.u_range()[0])\n        u_max=float(input.u_range()[1])\n\n\n        # Define rhs of logistic map \n        def logistic_map(y,t,r):\n          rhs=r*y*(1-y)\n          return rhs\n        \n        def DiscreteSol(rhs_pop_model,y_0,t,r):\n            y=np.zeros_like(t,dtype=float)\n            y[0]=y_0\n            for i in t:\n                if i&gt;0:\n\n                    y[i]=rhs_pop_model(y[i-1],t[i],r)\n            return y\n\n        # Define discretised t domain\n        t = np.arange(0, T, 1)\n        # define initial conditions\n        init_cond=u0\n        \n        # Compute numerical solution of ODEs\n        sol1 = DiscreteSol(logistic_map,init_cond,t,r)\n\n        # Plot results\n        y=sol1\n        \n        ax[0].plot(t,y)\n        ax[0].set_xlabel('$n$')\n        ax[0].set_ylabel('$y_n$')\n        ax[0].set_ylim([-0.05,1.05])\n\n        plt.grid()\n\n        # Parameters\n        n_iterations = 1000  # total iterations for each value of r\n        n_last = 100         # number of iterations to plot (for steady state)\n        r_values = np.linspace(0.0, 4.0, 10000)  # range of r values\n        u0 = 0.5  # initial population (seed)\n\n        delta=0.25\n        #r_min=r-delta\n        #r_max=r+delta\n\n        r_values2 = np.linspace(r_min, r_max, 10000)  # range of r values\n\n        # Initialize plot\n        x = np.full_like(r_values, u0)\n        x2 = np.full_like(r_values2, u0)\n\n        # Iterate and plot bifurcation diagram\n         \n        for _ in range(n_iterations):\n            x = r_values * x * (1 - x)  # logistic map function\n            x2 = r_values2 * x2 * (1 - x2)  # logistic map function\n\n            if _ &gt;= (n_iterations - n_last):  # plot only steady state\n                ax[1].plot(r_values, x, ',k', alpha=0.25)\n                ax[1].plot([r,r],[0,1],'r--')\n                ax[2].plot(r_values2, x2, ',k', alpha=0.25)\n                ax[2].plot([r,r],[0,1],'r--')\n\n            # Labels and display\n            ax[1].set_title(\"Bifurcation Diagram\")\n            ax[1].set_xlabel(\"$r$\")\n            ax[1].set_ylabel(\"$y^*$\")\n            ax[2].set_title(\"Bifurcation Diagram (zoomed in) \")\n            ax[2].set_xlabel(\"$r$\")\n            ax[2].set_ylabel(\"$y^*$\")\n            ax[2].set_xlim([r_min,r_max])\n            ax[2].set_ylim([u_min,u_max])\n\n\n\n        plt.show()\n    \napp = App(app_ui, server)\n\n\nFigure 1.2: Exploring behaviour of the logistic map using numerical solutions and bifurcation diagrams.\n\n\n\n\n1.1.3 Key questions to ask of a dynamical system\n\ndo solutions exist? If so are they unique?\nIs there an explicit solution?\nCan we qualitatively describe solution behaviour?\nHow do the solutions depend on the model parameters?\nAre their critical values of parameters where solution behaviour changes?\n\n\n\n1.2 Autonomous v nonautonomous ODEs\nFor an autonomous system, the update does not explicitly depend on the independent variable. Equation 1.1 is autonomous. But \\[\n\\dot{x}=rx(1-x+t)\n\\] is nonautonomous (because of the explicit time dependence on the right-hand side).\n\n\n1.3 Linear v Nonlinear\nLinear systems satisfy a linear supposition principle: a sum of solutions is itself a solution. In general, this property does not hold for nonlinear systems.\nIn linear dynamical systems, the dynamics are a function of linear sums of the dependent variables. Hence\n\\[\n\\dot{x}=-x\n\\tag{1.3}\\] is a linear ordinary differential equation (ODE). But \\[\n\\dot{x}=-x^2\n\\tag{1.4}\\] is nonlinear.\n\nExample 1.2 Integrate each of Equation 1.3 and Equation 1.4. Use the solutions to demonstrate that the principle of linear superpositions holds for Equation 1.3 but not for Equation 1.4.\n\n\n\n1.4 Quantitative v qualitative solutions\nYou are likely used to solving problems in which an explicit solution can be found. For example, consider the ODE \\[\n\\dot{x}=-kx, \\quad  x(0)=x_0\n\\] where \\(k,x_0 \\in \\Re^+\\) .\nWe can integrate and express the solution as\n\\[\nx(t)=x_0e^{-kt}\n\\]\nUsing the explicit solution we can then answer questions about its behaviour. For example, let’s say we want to find the time, \\(t^*\\), at which the solution is half it’s maximum. Hence \\[\nx(t*)=x_0/2 \\implies t^* = \\frac{\\ln 2}{k}.\n\\]\nHowever, almost all problems that we will encounter in the study of nonlinear systems will not have an explicit solution. For example, consider the nonlinear ODE\n\\[\n\\dot{x}=-\\frac{k\\sin(x)+\\sqrt{x}}{1+x}, \\quad  x(0)=x_0,\n\\] where \\(0&lt;x_0&lt;\\pi\\).\nI cannot integrate this equation in order to find solutions in terms of standard functions. Hence I cannot quantitatively describe the solution. However, I can identify that\n\\[\n\\dot{x}&lt;0, \\  \\forall \\  0&lt;x&lt;\\pi.\n\\]\nHence the solution will decrease in value from the given initial condition and tend to zero as \\(t\\rightarrow \\infty\\). This is an example of a qualitative analysis.\n\n\n1.5 Representing solutions\nIt is useful to define some important concepts that are used to describe the solutions of a dynamical system. Consider an ODE \\[\n\\dot{\\mathbf{x}}=\\mathbf{f}(\\mathbf{x}), \\quad \\mathbf{x}(0)=\\mathbf{x}_0,\n\\] where \\(\\mathbf{f}\\) is a prescribed function and \\(\\mathbf{x}_0\\) is an initial condition.\n\nphase space - a Cartesian coordinate system with dependent variables represented on Cartesian axes\nphase point - value of the solution at given time point\nvector field - the derivative of the solution, i.e. \\(\\mathbf{f}\\).\ntrajectory - a line in phase space that traces out a solution as time evolves (must be tangential to vector field)\nphase portrait - collection of trajectories (i.e. solutions with different initial conditions)\n\n\n\n1.6 Fixed points and their stability\nMany of the dynamical systems that we will study will be nonlinear. Hence it will not be possible to compute exact solutions.\nThe behaviour of dynamical systems can often be understood by considering the fixed points, i.e. values of the dependent variables at which the dynamics are at steady state.\nStability analyses are used to investigate the dynamics of perturbations about the steady state.\n\n\n1.7 Uniqueness and existence\nWe will restrict ourselves to problems in which the vector fields are sufficiently well behaved such that unique solutions exist.\n\nTheorem 1.1 TheoremSuppose that \\[\n\\dot{{x}}=f(x), \\quad x(0)=x_0.\n\\tag{1.5}\\]\nIf \\(f\\) is continuously differentiable on an open interval \\(D\\) of the \\(x\\) axis and \\(x_0\\) is a point in \\(D\\), Equation 1.5 possesses a unique solution on some time interval \\((-\\tau,\\tau)\\).\n\n\nHowever, it is noted that problems can be identified where solutions do not exist or where multiple solutions exist.\n\nExample 1.3 Show that the solution to the ODE \\[\n\\dot{x}=x^2 \\quad x(0)=2\n\\] blows up after a finite time.\nIs this result consistent with Theorem 1.1?\n\n\nExample 1.4 Show that the solution to the ODE \\[\n\\dot{x}=\\sqrt{x}, \\quad x(0)=0\n\\] is given by \\[\nx=\\begin{cases}\n&0, \\ \\ t\\leq\\delta \\\\\n&\\frac{(t-\\delta)^2}{4}&gt;\\delta, \\  \\ t&gt; \\delta\n\\end{cases}\n\\] for any \\(\\delta &gt;0\\). Why does this form imply that the solution is not unique? Is this result consistent with Theorem 1.1?\n\n\n\n1.8 Nondimensionalisation\nIn real world problems, variables and parameters typically have units (e.g. time - seconds, Force - Newtons etc.). We can nondimensionalise problems by defining rescaled variables. This process can be used to justify simplifications to models and to reduce the number of parameters.\n\n\n1.9 Numerical solutions\nNumerical solutions are used to numerically compute approximate solutions to problems. The simplest example of a numerical method in a dynamical system is the forward Euler method. Suppose we want to study the ODE\n\\[\n\\dot{x}=f(x), \\quad x(0)=x_0, \\quad 0&lt;t&lt;T.\n\\]\nDiscretise the independent variable \\(t\\) by defining \\(t=0\\),\\(\\Delta t\\),\\(2\\Delta t\\),…,\\(T=N\\Delta T\\).\nApproximate the time derivative\n\\[\n\\dot{x}=\\frac{dx}{dt}\\sim \\frac{x(t+\\Delta t)-x(t)}{\\Delta t}\n\\]\nHence the solution at time \\(t+\\Delta t\\) can be approximated by \\[\nx(t+\\Delta t)=x(t)+\\Delta t f(x(t)).\n\\]\nGiven an initial condition \\(x(0)=a\\) we can compute the approximate solution at time \\(\\Delta t\\). Further iteration then allows an approximate solution to be calculated.\nNumerical solutions provide a a very useful way to explore solution behaviour. However, they describe the quantitative behaviour of a solution for a particular initial condition and set of parameter values.\n\nExample 1.5 The app below uses the Forward Euler method to compute numerical solutions of the ODE \\[\n\\dot{x}=a+bx+cx^2\n\\] in the domain \\([0,T]\\) with initial condition \\[\nx(0)=x_0.\n\\]\n\nChoose model parameters so that the app solves the ODE \\[\n\\dot{x}=-bx, \\quad x(0)=x_0.\n\\] and show that the numerical solution agrees (eye ball norm) with the exact solution (dashed line).\nShow that the numerical error increases with \\(\\Delta t\\).\n\n\n\n\n#| '!! shinylive warning !!': |\n#|   shinylive does not work in self-contained HTML documents.\n#|   Please set `embed-resources: false` in your metadata.\n#| standalone: true\n#| viewerHeight: 800\n\n\n\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\n\napp_ui = ui.page_fluid(\n                 \n    ui.input_slider(id=\"x0\",label=\"x_0\",min=0.0,max=10.0,value=0.5,step=0.01),\n    ui.input_slider(id=\"T\",label=\"T\",min=0.0,max=60.0,value=20.0,step=1.0),\n    ui.input_slider(id=\"a\",label=\"a\",min=-5.0,max=5.0,value=-1.0,step=0.01),\n    ui.input_slider(id=\"b\",label=\"b\",min=-5.0,max=5.0,value=2.0,step=0.01),ui.output_plot(\"plot\"),\n    ui.input_slider(id=\"c\",label=\"c\",min=-5.0,max=5.0,value=0.1,step=0.01),\n    ui.input_slider(id=\"dt\",label=\"dt\",min=0.0,max=1.0,value=0.01,step=0.001),\n)\n\ndef server(input, output, session):\n    @output\n    @render.plot\n    def plot():\n        fig, ax = plt.subplots(1,1,figsize=(12, 4))\n       \n        x0=float(input.x0())\n        T=float(input.T())\n        a=float(input.a())\n        b=float(input.b())\n        c=float(input.c())\n        dt=float(input.dt())\n\n\n        # Define rhs of logistic map \n        def oderhs(y,a,b,c):\n          rhs=a+b*y+c*y**2\n          return rhs\n        \n        def FESol(y_0,t,a,b,c,dt):\n            y=np.zeros_like(t,dtype=float)\n            y[0]=y_0\n            for i in range(len(t)):\n                if i&gt;0:\n                    y[i]=y[i-1]+dt*oderhs(y[i-1],a,b,c)\n            return y\n\n        N=int(np.ceil(T/dt))\n        # Define discretised t domain\n        t = np.linspace(0, T,N)\n        \n        # Compute numerical solution of ODEs\n        sol1 = FESol(x0,t,a,b,c,dt)\n\n        # Plot results\n        y=sol1\n        \n        model_sol=x0*np.exp(b*t)\n        ax.plot(t,y,t,model_sol,'--')\n        ax.set_xlabel('$t$')\n        ax.set_ylabel('$x(t)$')\n        ax.set_ylim([0,2*x0])\n\n        fig.legend(['Num','$x_0e^{bt}$'])\n\n        plt.grid()\n\n        plt.show()\n    \napp = App(app_ui, server)\n\n\nFigure 1.3: Numerical solution of an ODE with a quadratic right-hand side.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "intro.html#autonomous-v-nonautonomous-odes",
    "href": "intro.html#autonomous-v-nonautonomous-odes",
    "title": "1  Introduction",
    "section": "",
    "text": "For an autonomous system, the update does not explicitly depend on the independent variable. Equation 1.1 is autonomous. But \\[\n\\dot{x}=rx(1-x+t)\n\\] is nonautonomous (because of the explicit time dependence on the right-hand side).",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "intro.html#linear-v-nonlinear",
    "href": "intro.html#linear-v-nonlinear",
    "title": "1  Introduction",
    "section": "1.3 Linear v Nonlinear",
    "text": "1.3 Linear v Nonlinear\nLinear systems satisfy a linear supposition principle: a sum of solutions is itself a solution. In general, this property does not hold for nonlinear systems.\nIn linear dynamical systems, the dynamics are a function of linear sums of the dependent variables. Hence\n\\[\n\\dot{x}=-x\n\\tag{1.3}\\] is a linear ordinary differential equation (ODE). But \\[\n\\dot{x}=-x^2\n\\tag{1.4}\\] is nonlinear.\n\nExample 1.2 Integrate each of Equation 1.3 and Equation 1.4. Use the solutions to demonstrate that the principle of linear superpositions holds for Equation 1.3 but not for Equation 1.4.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "intro.html#quantitative-v-qualitative-solutions",
    "href": "intro.html#quantitative-v-qualitative-solutions",
    "title": "1  Introduction",
    "section": "1.4 Quantitative v qualitative solutions",
    "text": "1.4 Quantitative v qualitative solutions\nYou are likely used to solving problems in which an explicit solution can be found. For example, consider the ODE \\[\n\\dot{x}=-kx, \\quad  x(0)=x_0\n\\] where \\(k,x_0 \\in \\Re^+\\) .\nWe can integrate and express the solution as\n\\[\nx(t)=x_0e^{-kt}\n\\]\nUsing the explicit solution we can then answer questions about its behaviour. For example, let’s say we want to find the time, \\(t^*\\), at which the solution is half it’s maximum. Hence \\[\nx(t*)=x_0/2 \\implies t^* = \\frac{\\ln 2}{k}.\n\\]\nHowever, almost all problems that we will encounter in the study of nonlinear systems will not have an explicit solution. For example, consider the nonlinear ODE\n\\[\n\\dot{x}=-\\frac{k\\sin(x)+\\sqrt{x}}{1+x}, \\quad  x(0)=x_0,\n\\] where \\(0&lt;x_0&lt;\\pi\\).\nI cannot integrate this equation in order to find solutions in terms of standard functions. Hence I cannot quantitatively describe the solution. However, I can identify that\n\\[\n\\dot{x}&lt;0, \\  \\forall \\  0&lt;x&lt;\\pi.\n\\]\nHence the solution will decrease in value from the given initial condition and tend to zero as \\(t\\rightarrow \\infty\\). This is an example of a qualitative analysis.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "intro.html#representing-solutions",
    "href": "intro.html#representing-solutions",
    "title": "1  Introduction",
    "section": "1.5 Representing solutions",
    "text": "1.5 Representing solutions\nIt is useful to define some important concepts that are used to describe the solutions of a dynamical system. Consider an ODE \\[\n\\dot{\\mathbf{x}}=\\mathbf{f}(\\mathbf{x}), \\quad \\mathbf{x}(0)=\\mathbf{x}_0,\n\\] where \\(\\mathbf{f}\\) is a prescribed function and \\(\\mathbf{x}_0\\) is an initial condition.\n\nphase space - a Cartesian coordinate system with dependent variables represented on Cartesian axes\nphase point - value of the solution at given time point\nvector field - the derivative of the solution, i.e. \\(\\mathbf{f}\\).\ntrajectory - a line in phase space that traces out a solution as time evolves (must be tangential to vector field)\nphase portrait - collection of trajectories (i.e. solutions with different initial conditions)",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "intro.html#fixed-points-and-their-stability",
    "href": "intro.html#fixed-points-and-their-stability",
    "title": "1  Introduction",
    "section": "1.6 Fixed points and their stability",
    "text": "1.6 Fixed points and their stability\nMany of the dynamical systems that we will study will be nonlinear. Hence it will not be possible to compute exact solutions.\nThe behaviour of dynamical systems can often be understood by considering the fixed points, i.e. values of the dependent variables at which the dynamics are at steady state.\nStability analyses are used to investigate the dynamics of perturbations about the steady state.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "intro.html#uniqueness-and-existence",
    "href": "intro.html#uniqueness-and-existence",
    "title": "1  Introduction",
    "section": "1.7 Uniqueness and existence",
    "text": "1.7 Uniqueness and existence\nWe will restrict ourselves to problems in which the vector fields are sufficiently well behaved such that unique solutions exist.\n\nTheorem 1.1 TheoremSuppose that \\[\n\\dot{{x}}=f(x), \\quad x(0)=x_0.\n\\tag{1.5}\\]\nIf \\(f\\) is continuously differentiable on an open interval \\(D\\) of the \\(x\\) axis and \\(x_0\\) is a point in \\(D\\), Equation 1.5 possesses a unique solution on some time interval \\((-\\tau,\\tau)\\).\n\n\nHowever, it is noted that problems can be identified where solutions do not exist or where multiple solutions exist.\n\nExample 1.3 Show that the solution to the ODE \\[\n\\dot{x}=x^2 \\quad x(0)=2\n\\] blows up after a finite time.\nIs this result consistent with Theorem 1.1?\n\n\nExample 1.4 Show that the solution to the ODE \\[\n\\dot{x}=\\sqrt{x}, \\quad x(0)=0\n\\] is given by \\[\nx=\\begin{cases}\n&0, \\ \\ t\\leq\\delta \\\\\n&\\frac{(t-\\delta)^2}{4}&gt;\\delta, \\  \\ t&gt; \\delta\n\\end{cases}\n\\] for any \\(\\delta &gt;0\\). Why does this form imply that the solution is not unique? Is this result consistent with Theorem 1.1?",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "intro.html#nondimensionalisation",
    "href": "intro.html#nondimensionalisation",
    "title": "1  Introduction",
    "section": "1.8 Nondimensionalisation",
    "text": "1.8 Nondimensionalisation\nIn real world problems, variables and parameters typically have units (e.g. time - seconds, Force - Newtons etc.). We can nondimensionalise problems by defining rescaled variables. This process can be used to justify simplifications to models and to reduce the number of parameters.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "intro.html#numerical-solutions",
    "href": "intro.html#numerical-solutions",
    "title": "1  Introduction",
    "section": "1.9 Numerical solutions",
    "text": "1.9 Numerical solutions\nNumerical solutions are used to numerically compute approximate solutions to problems. The simplest example of a numerical method in a dynamical system is the forward Euler method. Suppose we want to study the ODE\n\\[\n\\dot{x}=f(x), \\quad x(0)=x_0, \\quad 0&lt;t&lt;T.\n\\]\nDiscretise the independent variable \\(t\\) by defining \\(t=0\\),\\(\\Delta t\\),\\(2\\Delta t\\),…,\\(T=N\\Delta T\\).\nApproximate the time derivative\n\\[\n\\dot{x}=\\frac{dx}{dt}\\sim \\frac{x(t+\\Delta t)-x(t)}{\\Delta t}\n\\]\nHence the solution at time \\(t+\\Delta t\\) can be approximated by \\[\nx(t+\\Delta t)=x(t)+\\Delta t f(x(t)).\n\\]\nGiven an initial condition \\(x(0)=a\\) we can compute the approximate solution at time \\(\\Delta t\\). Further iteration then allows an approximate solution to be calculated.\nNumerical solutions provide a a very useful way to explore solution behaviour. However, they describe the quantitative behaviour of a solution for a particular initial condition and set of parameter values.\n\nExample 1.5 The app below uses the Forward Euler method to compute numerical solutions of the ODE \\[\n\\dot{x}=a+bx+cx^2\n\\] in the domain \\([0,T]\\) with initial condition \\[\nx(0)=x_0.\n\\]\n\nChoose model parameters so that the app solves the ODE \\[\n\\dot{x}=-bx, \\quad x(0)=x_0.\n\\] and show that the numerical solution agrees (eye ball norm) with the exact solution (dashed line).\nShow that the numerical error increases with \\(\\Delta t\\).\n\n\n\n\n#| '!! shinylive warning !!': |\n#|   shinylive does not work in self-contained HTML documents.\n#|   Please set `embed-resources: false` in your metadata.\n#| standalone: true\n#| viewerHeight: 800\n\n\n\n\nfrom shiny import App, Inputs, Outputs, Session, render, ui\nfrom shiny import reactive\n\nimport numpy as np\nfrom pathlib import Path\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\n\napp_ui = ui.page_fluid(\n                 \n    ui.input_slider(id=\"x0\",label=\"x_0\",min=0.0,max=10.0,value=0.5,step=0.01),\n    ui.input_slider(id=\"T\",label=\"T\",min=0.0,max=60.0,value=20.0,step=1.0),\n    ui.input_slider(id=\"a\",label=\"a\",min=-5.0,max=5.0,value=-1.0,step=0.01),\n    ui.input_slider(id=\"b\",label=\"b\",min=-5.0,max=5.0,value=2.0,step=0.01),ui.output_plot(\"plot\"),\n    ui.input_slider(id=\"c\",label=\"c\",min=-5.0,max=5.0,value=0.1,step=0.01),\n    ui.input_slider(id=\"dt\",label=\"dt\",min=0.0,max=1.0,value=0.01,step=0.001),\n)\n\ndef server(input, output, session):\n    @output\n    @render.plot\n    def plot():\n        fig, ax = plt.subplots(1,1,figsize=(12, 4))\n       \n        x0=float(input.x0())\n        T=float(input.T())\n        a=float(input.a())\n        b=float(input.b())\n        c=float(input.c())\n        dt=float(input.dt())\n\n\n        # Define rhs of logistic map \n        def oderhs(y,a,b,c):\n          rhs=a+b*y+c*y**2\n          return rhs\n        \n        def FESol(y_0,t,a,b,c,dt):\n            y=np.zeros_like(t,dtype=float)\n            y[0]=y_0\n            for i in range(len(t)):\n                if i&gt;0:\n                    y[i]=y[i-1]+dt*oderhs(y[i-1],a,b,c)\n            return y\n\n        N=int(np.ceil(T/dt))\n        # Define discretised t domain\n        t = np.linspace(0, T,N)\n        \n        # Compute numerical solution of ODEs\n        sol1 = FESol(x0,t,a,b,c,dt)\n\n        # Plot results\n        y=sol1\n        \n        model_sol=x0*np.exp(b*t)\n        ax.plot(t,y,t,model_sol,'--')\n        ax.set_xlabel('$t$')\n        ax.set_ylabel('$x(t)$')\n        ax.set_ylim([0,2*x0])\n\n        fig.legend(['Num','$x_0e^{bt}$'])\n\n        plt.grid()\n\n        plt.show()\n    \napp = App(app_ui, server)\n\n\nFigure 1.3: Numerical solution of an ODE with a quadratic right-hand side.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "1DFlows.html",
    "href": "1DFlows.html",
    "title": "2  Flows on the line",
    "section": "",
    "text": "2.1 Geometric\nHere we consider ODE models with a single dependent variable that are first order in time.\nLet \\(x=x(t)\\). \\[\n\\dot{x}=f(x).\n\\tag{2.1}\\]\nIt is assumed that \\(f\\) is smooth and real valued.\nFor many problem an explicit solution can either not be constructed or is not of practical use.\nAfter applying separation of variables, an implicit solution is given by\n\\[\nt=-\\ln |\\csc x + \\cot x| + C,\n\\] where \\(C\\) is an integration constant.\nHowever, this does not help me to describe the limiting behaviour of the solution as \\(t\\rightarrow \\infty\\).\nInstead let’s use a graphical method. In Figure 2.1 we sketch a graph of \\(f\\), the right-hand side of the ODE. The arrows depict the vector field. Hence when \\(f&gt;0\\), \\(\\dot{x}&gt;0\\) and the solution increases. In contrast, when \\(f&lt;0\\), \\(\\dot{x}&lt;0\\) and the solution decreases.\nNote that \\(f&gt;0  \\ \\forall \\ 0&lt;x&lt;\\pi\\). Hence for initial condition \\(x_0=\\pi/4\\), \\(\\dot{x}_{t=0}&gt;0\\). The solution will increase until it reaches \\(\\pi\\). At \\(x=\\pi\\), \\(f=0\\).",
    "crumbs": [
      "1D flows",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Flows on the line</span>"
    ]
  },
  {
    "objectID": "1DFlows.html#geometric",
    "href": "1DFlows.html#geometric",
    "title": "2  Flows on the line",
    "section": "",
    "text": "Example 2.1 Let \\(x(t)\\). Consider the ODE \\[\n\\dot{x}=\\sin x.\n\\]\nFor the initial condition \\(x(0)=\\pi/4\\), describe solution behaviour as \\(t\\rightarrow \\infty\\).\n\n\n\n\n\n\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nx=np.linspace(-5,5)\n\ny=np.sin(x)\n\nfig,ax=plt.subplots()\n\nax.plot(x,y)\nax.set_xlabel('$x$')\nax.set_ylabel('$\\dot{x}$')\n# Arrow target (arrow head)\nx=[np.pi, np.pi, -np.pi, -np.pi]\ny=[0.0, 0.0,0.0,0.0]\n\n# Arrow start\nx0=[0.0,2.0*np.pi,0.0,-2.0*np.pi]\ny0 = [0.0,0.0,0.0,0.0]\n\n\nfor x_i,y_i,x0_i,y0_i in zip(x,y,x0,y0):\n  ax.annotate('',\n      xy=(x_i, y_i),        # arrow head\n      xytext=(x0_i, y0_i),  # arrow tail\n      arrowprops=dict(\n          arrowstyle='-&gt;',\n          color='black'\n      ),\n      ha='center'\n  )\n  \nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2.1",
    "crumbs": [
      "1D flows",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Flows on the line</span>"
    ]
  },
  {
    "objectID": "1DFlows.html#fixed-points-and-linear-stability",
    "href": "1DFlows.html#fixed-points-and-linear-stability",
    "title": "2  Flows on the line",
    "section": "2.2 Fixed points and linear stability",
    "text": "2.2 Fixed points and linear stability\n\n2.2.1 Fixed points\nLet \\(x=x^*\\) be a fixed point of Equation 2.1. At \\(x=x^*\\) \\[\n\\dot{x}=0 \\implies f(x^*)=0.\n\\]\nThere are a number of interpretations of \\(x^*\\):\n\nroots of \\(f\\) (algebraic)\nstagnation points of the flow (topological)\n\n\nCorollary 1Any trajectory initialised at a fixed point remains there for all \\(t\\).\n\n\n\nExample 2.2 Find all the fixed points of \\[\n\\dot{x}=x^2-1,\n\\tag{2.2}\\]\n\n\nSolutionThe fixed points are point, \\(x^*\\) defined such that \\[\n\\dot{x}=0 \\ \\implies \\ f(x^*)=0.\n\\]\nHence fixed points satisfy \\[\n{x^*}^2-1=0.\n\\]\nThe solutions are \\[\nx^*=\\pm 1.\n\\]\nSee Figure 2.2 for graphical solution.\n\n\n\nCode\nimport numpy as np\n\nx=np.linspace(-2,2)\n\ny=x**2-1\n\nfig,ax=plt.subplots()\n\nax.plot(x,y)\nax.set_xlabel('$x$')\nax.set_ylabel('$f$')\nax.grid(True)\nax.set_ylim([-2,3])\n\n\n# Arrow target (arrow head)\nx=[-1.0, -1.0, 1.0, 1.0]\ny=[0.0, 0.0,0.0,0.0]\n\n# Arrow start\nx0=[-2.0,2.0,0.0,2.0]\ny0 = [0.0,0.0,0.0,0.0]\n\n\nfor x_i,y_i,x0_i,y0_i in zip(x,y,x0,y0):\n  ax.annotate('',\n      xy=(x_i, y_i),        # arrow head\n      xytext=(x0_i, y0_i),  # arrow tail\n      arrowprops=dict(\n          arrowstyle='-&gt;',\n          color='black'\n      ),\n      ha='center'\n  )\n  \n\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 2.2: Graphical solution of Equation 2.2.\n\n\n\n\n\n2.2.2 Linear stability analysis\nLet \\(x=x^*\\) be a fixed point of Equation 2.1.\n\n2.2.2.1 A change of dependent variable\nTo perform a linear stability analysis we make the change of variables \\[\nx(t)=x^*+\\hat{x}(t)\n\\] where the new dependent variable, \\(\\hat{x}(t)\\), is a perturbation about the fixed point.\nThe time derivative on the left-hand side of Equation 2.1 transforms to \\[\n\\dot{x}= \\frac{d }{dt} (x^*) + \\frac{d }{dt}(\\hat{x}(t))=\\dot{\\hat{x}}.\n\\] Hence Equation 2.1 transforms to \\[\n\\dot{\\hat{x}} = f(x^*+\\hat{x}(t)).\n\\]\n\n\n2.2.2.2 Taylor expansion and a linear system\nEmploying the Taylor expansion on the right-hand side of Equation 2.1 and making the assumption that perturbations are small \\[\n\\dot{\\hat{x}} = f(x^*)+  f'(x^*)\\hat{x}(t) + f''(x^*)\\hat{x}^2(t) + h.o.t.\n\\] Noting that\n\\[\nf(x^*)=0\n\\] and retaining linear terms yields \\[\n\\dot{\\hat{x}} =  f'(x^*)\\hat{x}(t)\n\\] with solution \\[\n\\hat{x}(t)=  \\eta e^{f'(x^*) t}\n\\] where \\(\\eta\\) is some initial perturbation about the steady-state.\n\n\n2.2.2.3 A condition for linear stability\nWhen \\(f'(x^*)&gt;0\\) the perturbation grows exponentially fast and the steady-state is linearly unstable. When \\(f'(x^*)&lt;0\\) the perturbation decays exponentially fast and the steady-state is linearly stable.\n\nExample 2.3 Determine the linear stability of the fixed points of \\[\n\\dot{x}=x^2-1.\n\\]\n\n\nExample 2.4 What can be said about the stability of the fixed points of the following ODEs:\n\n\\[\n\\dot{x}=-x^3.\n\\]\n\\[\n\\dot{x}=x^3.\n\\]\n\\[\n\\dot{x}=0.\n\\]",
    "crumbs": [
      "1D flows",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Flows on the line</span>"
    ]
  },
  {
    "objectID": "1DFlows.html#validity-of-linear-classification",
    "href": "1DFlows.html#validity-of-linear-classification",
    "title": "2  Flows on the line",
    "section": "2.3 Validity of linear classification",
    "text": "2.3 Validity of linear classification\nIt is worth highlighting here that\n\\[\nf'(x*)\n\\] can be interpreted as an eigenvalue of the linearised problem \\[\n\\dot{\\hat{x}}=\\lambda \\hat{x}.\n\\] where \\[\n\\lambda = f'(x^*).\n\\]\nA fixed point is said to be hyperbolic when the eigenvalues of its linearisation are nonzero.\nThe Hartman-Grobman theorem states that if a system has a hyperbolic FP, the classification of the nonlinear system is determined by the linear classification.\nIf a fixed point is non-hypberbolic, it’s classification requires consideration of higher order terms.",
    "crumbs": [
      "1D flows",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Flows on the line</span>"
    ]
  },
  {
    "objectID": "1DFlows.html#case-study-population-dynamics",
    "href": "1DFlows.html#case-study-population-dynamics",
    "title": "2  Flows on the line",
    "section": "2.4 Case study: population dynamics",
    "text": "2.4 Case study: population dynamics\nLet \\(N=N(t)\\). The logistic model of population growth, due to Verhulst, takes the form \\[\n\\dot{N}=rN(t)\\left (1-\\frac{N(t)}{K}\\right),\n\\tag{2.3}\\]\nwhere \\(r\\) is the linear growth rate and \\(K\\) is carrying capacity. We consider both \\(r,K\\in \\Re^+\\).\nQuestions to ask of such a model are: what type of biologically realistic solutions does it possess? Are there fixed points? If so, are they stable or unstable?\n\n2.4.0.1 Numerical solutions\nIn Figure 2.3 we present numerical solutions of equation using different initial conditions. Note the limiting behaviour of solutions as \\(t\\rightarrow \\infty\\). In Figure 2.3 it is clear that even though some solutions are initialised at \\(N_0=0.1\\), much closer to \\(N^*=0\\) than \\(N^*=K\\), they tend to the limit \\(N=K\\). Why do solutions not tend to \\(N^*=0\\)?\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport scipy\nfrom scipy.integrate import odeint\n# This codes computes a numerical solution of the logistic growth model\n\n\n# Define model parameters\nK=12\nr_1=0.22\nr_2=0.42\nr_3=0.72\n\n# Plotting parameter\nN_max=1.1\n\n# Initial condition\nn_0=1.5\n# Max time\nT=20\nt=np.linspace(0,T,100)\n\ndef rhslogistic_model(x,t,r,K):\n\n  rhs=r*x*(1-x/K)\n  return rhs\n\n# Numerically solve the ODE for different parameter values\nsol1=odeint(rhslogistic_model,n_0,t,args=(r_1,K))\nsol2=odeint(rhslogistic_model,n_0,t,args=(r_2,K))\nsol3=odeint(rhslogistic_model,n_0,t,args=(r_3,K))\n\n\n# Plot solutions\nfig, ax = plt.subplots(1)\n\nax.plot(t, sol1,t, sol2,t, sol3)\nplt.xlabel('$t$')\nplt.ylabel('$N$')\nplt.grid(True)\nplt.legend(['r='+str(r_1),'r='+str(r_2),'r='+str(r_3)])\nplt.show()\n\n\n\n\n\n\n\n\nFigure 2.3: Numerical solution of the logistic growth model\n\n\n\n\n\n\n\n2.4.0.2 Dimensional analysis and nondimensionalisation\n\\(N\\) represents the population density and has units of one over area (say \\(1/m^2\\)) and \\(t\\) has units of time (say, seconds, \\(s\\)). Hence the left-hand side of Equation 2.3 has units of \\(1/(m^2 s)\\). The first term on the right-hand side of Equation 2.3 is \\(rN\\). \\(N\\) has units \\(1/m^2\\) hence the parameter \\(r\\) must have units of \\(1/s\\) for dimensional consistency. This is consistent as \\(r\\) represents the linear growth rate.\nThe second term has the form \\(rN^2/K\\). Given the chosen units for \\(r\\) and \\(N\\), the parameter \\(K\\) must have dimensions \\(1/m^2\\). Again, this is consistent as \\(K\\) is a carrying capacity (i.e. it has units of population density).\nWe define the nondimensionalised variables \\[\nn=\\frac{N}{\\tilde{N}} \\ \\ \\ \\ \\ \\ \\tau=\\frac{t}{\\tilde{T}}\n\\] where \\(\\tilde{N}\\) and \\(\\tilde{T}\\) are constants that have units of population density and time, respectively. Hence Equation 2.3 transforms, upon change of variables, to \\[\n\\begin{aligned}\n\\frac{\\tilde{N}}{\\tilde{T} }\\frac{dn}{d\\tau}=r\\tilde{N}n(1-\\frac{n\\tilde{N}}{K}).\n\\end{aligned}\n\\]\nIn the case of the logistic equation there is only one time scale and density scale in the problem, hence we choose \\[\n\\tilde{T}=\\frac{1}{r}  \\ \\ \\ and \\ \\ \\ \\tilde{N}=K\n\\] and the dimensionless model is \\[\n\\begin{aligned}\n\\frac{dn}{d\\tau}= n(1-n)\n\\end{aligned}\n\\tag{2.4}\\] Note that we can retrieve the original equation by rescaling and calculating \\(N=\\tilde{N}n\\) and \\(t=\\tilde{T}\\tau\\).\n\n\n2.4.1 Fixed points and linear stability\nFixed points satisfy \\[\nn^*(1-n^*)=0.\n\\] Hence \\[\nn^*=0, \\ \\ \\ \\ n^*=1.\n\\]\nTo determine linear stability we compute \\[\nH'(n)= (1-2n).\n\\] When \\(n=n^*=0\\) we obtain \\[\nH'(n)= 1.\n\\] Hence the origin is a linearly unstable fixed point.\nAt the steady-state \\(n^*=1\\) \\[\nH'(n^*)= -1\n\\] hence \\(n^*=1\\) is linearly stable.\nNote that the linear stability analysis can explain the observations regarding the numeric solutions presented in Figure 2.3.\n\n\n2.4.2 Graphical analysis\nIn Figure 2.4 we plot the right-hand side of Equation 2.4. We can qualitatively describe model solutions by considering the arrow along the \\(n\\) axis. Suppose we consider an initial condition with \\(0&lt;n_0&lt;1\\). Using the graph of \\(H(n)\\), \\(dn/d\\tau\\) is positive, hence \\(n\\) increases as a function of time until \\(n(\\tau)\\rightarrow 1\\).\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\nN_max=2.1\nK=2\nr=0.2\nN_vec=np.linspace(0,N_max,100)\n\nrhs=r*N_vec*(1-N_vec/K)\nfig, ax = plt.subplots(1)\n\nax.plot(N_vec, rhs)\nplt.xlabel('$N$')\nplt.ylabel('$H(N)$')\nplt.show()\n\n\n\n\n\n\n\n\nFigure 2.4: Right-hand side of the logistic ODE\n\n\n\n\n\n\nExample 2.5 Use separation of variables to show that the solution can be written explicitly as \\[\nN(t)=\\frac{N_0K e^{rt}}{K+N_0(e^{rt}-1)}\n\\]\n\n\nSolution\\[\n\\int\\frac{ dN}{N(1-\\frac{N}{K})}=r\\int dt.\n\\] Using partial fractions \\[\n\\int\\frac{ dN}{N} + \\frac{1}{K}\\int\\frac{ dN}{1-\\frac{N}{K}}=r\\int dt.\n\\] Integration yields \\[\n\\ln N - \\ln\\left(1-\\frac{N}{K}\\right)= \\ln \\frac{N }{1-\\frac{N}{K}} =  rt+C.\n\\] Hence \\[\nN=\\frac{De^{rt}}{1+\\frac{D}{K}e^{rt}}\n\\] Given an initial condition \\(N(0)=N_0\\), we obtain \\[\nN(t)=\\frac{N_0K e^{rt}}{K+N_0(e^{rt}-1)}\n\\]\n\n\n\n2.4.2.1 Qualitative analysis of the exact solution\nAs \\(t\\rightarrow \\infty\\), \\(N\\rightarrow K\\). At \\(t=0\\), \\(N=N_0\\) and that for small \\(N_0\\ll K\\) the initial growth phase is exponential, i.e.  \\[\nN(t)\\sim N_0 e^{rt} \\\\ \\ \\ \\ \\ N_0\\ll K, t\\ll \\frac{1}{r}.\n\\]",
    "crumbs": [
      "1D flows",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Flows on the line</span>"
    ]
  },
  {
    "objectID": "1DFlows.html#impossibility-of-oscillations",
    "href": "1DFlows.html#impossibility-of-oscillations",
    "title": "2  Flows on the line",
    "section": "2.5 Impossibility of oscillations",
    "text": "2.5 Impossibility of oscillations\nOscillatory solutions to Equation 1.5 are impossible, i.e. first order autonomous ODEs (with one dependent variable) cannot oscillate.\nThis can be argued using geometrical constraints of dynamics on the line.\n\nExample 2.6 Consider the integral \\[\n\\int_t^{t+T} f(x(t))\\frac{dx}{dt}dt,\n\\] where \\(T\\) is the oscillation period. Use proof by contradiction to show that periodic solutions are impossible.\n\n\nSolutionSuppose that a periodic solution exists such that \\[\nx(t+T)=x(t), \\ \\ x(t+s)\\neq x(t+T) \\forall 0&lt;s&lt;T.\n\\]\nConsider \\[\n\\int_t^{t+T} f(x(t))\\frac{dx}{dt}dt.\n\\]\nThis integral can be written as \\[\n\\int_t^{t+T} f(x(t))^2 dt&gt;0,\n\\] as \\(f\\) is not identically zero.\nChanging variables yields \\[\n\\int_{x(t)}^{x(t+T)} f(x) dx =0.\n\\]\nHence there is a contradiction and no periodic solutions exist.",
    "crumbs": [
      "1D flows",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Flows on the line</span>"
    ]
  },
  {
    "objectID": "1DFlows.html#potential-flows",
    "href": "1DFlows.html#potential-flows",
    "title": "2  Flows on the line",
    "section": "2.6 Potential flows",
    "text": "2.6 Potential flows\nConsider the ODE \\[\n\\dot{x}=f(x).\n\\]\nSuppose that \\[\nf(x)=-\\frac{d V(x)}{dx}.\n\\]\nNow consider \\[\n\\dot{V}.\n\\] Applying the chain rule \\[\n\\dot{V}=\\frac{dV}{dx}\\dot{x}=-(\\frac{dV}{dx})^2\\leq 0.\n\\]\nHence for a potential flow \\(V\\) is never increasing. Hence particle move to points of lower potential until they reach equilibrium given by \\[\nf(x)=-\\frac{d V(x)}{dx}=0.\n\\]\n\nExample 2.7 Graph the potential for the system \\[\n\\dot{x}=-x\n\\] and identify equilibrium points.",
    "crumbs": [
      "1D flows",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Flows on the line</span>"
    ]
  },
  {
    "objectID": "PythonAppendix.html",
    "href": "PythonAppendix.html",
    "title": "3  Python",
    "section": "",
    "text": "3.1 Symbolic calculations\nSymbolic calculations ahve been performed using the Python library Sympy.\nThis library comes with tutorials.\nYou are encouraged to familiarise yourself with the syntax by working through some of the tutorial examples provided at the links above.\nMany of the calculations that we do throughout the course involve solving systems of algebraic equations",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Python</span>"
    ]
  },
  {
    "objectID": "PythonAppendix.html#numerical-solution-of-difference-equations",
    "href": "PythonAppendix.html#numerical-solution-of-difference-equations",
    "title": "3  Python",
    "section": "3.2 Numerical solution of difference equations",
    "text": "3.2 Numerical solution of difference equations\nDifference equations have been solved using a for loop. Routinse have been written to solve either single or coupled system of difference equaitons.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Python</span>"
    ]
  },
  {
    "objectID": "PythonAppendix.html#numerical-integration-of-odes",
    "href": "PythonAppendix.html#numerical-integration-of-odes",
    "title": "3  Python",
    "section": "3.3 Numerical integration of ODEs",
    "text": "3.3 Numerical integration of ODEs\nThroughout the notes systems of ODEs have been integrated using the Scipy function odeint.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Python</span>"
    ]
  },
  {
    "objectID": "PythonAppendix.html#plotting",
    "href": "PythonAppendix.html#plotting",
    "title": "3  Python",
    "section": "3.4 Plotting",
    "text": "3.4 Plotting\nLine graphs are plotted using the Python library Matplotlib.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Python</span>"
    ]
  }
]