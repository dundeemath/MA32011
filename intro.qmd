# Introduction

Dynamical systems

The goal of this module is to provide an introduction to dynamical systems. We will introduce key mathematical concepts and explore examples from physics and biology.  
 
To begin with we introduce some key terminology.


## Discrete v continuous time


### Differential equations

Let $t$ be a continuous variable and $x=x(t)$. Consider the ordinary differential equation (ODE)
$$
\dot{x}=rx(1-x).
$$ {#eq-logdemo}

$\dot{x}$ is used to denote the time derivative, i.e.
$$
\dot{x}:=\frac{dx}{dt}.
$$

Similarly, the second order derivative is represented by 
 $$
\ddot{x}:=\frac{d^2x}{dt^2}.
$$

Many of the  second order ODE problems that we will examine originate from Newton's Second Law, i.e.

$$
m\ddot{x}=F(x)
$$
where $x(t)$ represents the position of a particle at time, $t$, $m$ represents a constant particle mass and $F$ a resultant force.

Consider the case in which $F$ represents a linear restoring force, i.e.
$$
F(x)=-kx.
$$
The equation of motion can be written as 
$$
\ddot{x}=-\mu x,
$$
where $\mu=-k/m$.


### Difference equations

Suppose that $n$ is a discrete variable. Let $y_n$ represent a dependent variable at iteration $n$. Consider the difference equation
$$
y_{n+1}=ry_n(1-y_n),
$$
where $r\in \Re$.

See this [link](https://dundeemath.github.io/Admissions/posts/RecurrenceRelations.html) for exploration of model solutions.

::: {#fig-logisticmodel}

```{shinylive-python}
#| standalone: true
#| components: [viewer]
#| viewerHeight: 500

from shiny import App, Inputs, Outputs, Session, render, ui
from shiny import reactive

import numpy as np
from pathlib import Path
import matplotlib.pyplot as plt
from scipy.integrate import odeint

app_ui = ui.page_fluid(
    ui.layout_sidebar(
        ui.sidebar(
    ui.input_slider(id="r",label="r",min=0.0,max=5.0,value=0.1,step=0.001),             
    ui.input_slider(id="u0",label="u_0",min=0.0,max=1.0,value=0.5,step=0.01),
    ui.input_slider(id="T",label="Number of iterations",min=0.0,max=60.0,value=20.0,step=1.0),
    ui.input_slider(id="r_range",label="r zoomed",min=0.0,max=4.0,value=[0.0,4.0],step=0.001),
    ui.input_slider(id="u_range",label="u zoomed",min=0.0,max=1.0,value=[0.0,1.0],step=0.01),
              
          
            ),

        ui.output_plot("plot"),
    ),
)

def server(input, output, session):
    
    @render.plot
    def plot():
        fig, ax = plt.subplots(3,1)
        #ax.set_ylim([-2, 2])
        # Filter fata
        
        
        r=float(input.r())
        u0=float(input.u0())
        T=int(input.T())
        r_min=float(input.r_range()[0])
        r_max=float(input.r_range()[1])
        u_min=float(input.u_range()[0])
        u_max=float(input.u_range()[1])


        # Define rhs of logistic map 
        def logistic_map(y,t,r):
          rhs=r*y*(1-y)
          return rhs
        
        def DiscreteSol(rhs_pop_model,y_0,t,r):
            y=np.zeros_like(t,dtype=float)
            y[0]=y_0
            for i in t:
                if i>0:

                    y[i]=rhs_pop_model(y[i-1],t[i],r)
            return y

        # Define discretised t domain
        t = np.arange(0, T, 1)
        # define initial conditions
        init_cond=u0
        
        # Compute numerical solution of ODEs
        sol1 = DiscreteSol(logistic_map,init_cond,t,r)

        # Plot results
        y=sol1
        
        ax[0].plot(t,y)
        ax[0].set_xlabel('$n$')
        ax[0].set_ylabel('$y_n$')

        plt.grid()

        # Parameters
        n_iterations = 1000  # total iterations for each value of r
        n_last = 100         # number of iterations to plot (for steady state)
        r_values = np.linspace(0.0, 4.0, 10000)  # range of r values
        u0 = 0.5  # initial population (seed)

        delta=0.25
        #r_min=r-delta
        #r_max=r+delta

        r_values2 = np.linspace(r_min, r_max, 10000)  # range of r values

        # Initialize plot
        x = np.full_like(r_values, u0)
        x2 = np.full_like(r_values2, u0)

        # Iterate and plot bifurcation diagram
         
        for _ in range(n_iterations):
            x = r_values * x * (1 - x)  # logistic map function
            x2 = r_values2 * x2 * (1 - x2)  # logistic map function

            if _ >= (n_iterations - n_last):  # plot only steady state
                ax[1].plot(r_values, x, ',k', alpha=0.25)
                ax[1].plot([r,r],[0,1],'r--')
                ax[2].plot(r_values2, x2, ',k', alpha=0.25)
                ax[2].plot([r,r],[0,1],'r--')

            # Labels and display
            ax[1].set_title("Bifurcation Diagram")
            ax[1].set_xlabel("$r$")
            ax[1].set_ylabel("$y^*$")
            ax[2].set_title("Bifurcation Diagram (zoomed in) ")
            ax[2].set_xlabel("$r$")
            ax[2].set_ylabel("$y^*$")
            ax[2].set_xlim([r_min,r_max])
            ax[2].set_ylim([u_min,u_max])



        plt.show()
    
app = App(app_ui, server)
```
:::




### Key questions

 - do solutions exist? If so are they unique?
 - Is there an explicit solution?
 - Can we qualitatively describe solutions?
 - How do the solutions depend on the model parameters? 


## Autonomous v nonautonomous

For an autonomous system, the update does not explicitly depend on the independent variable. @eq-logdemo is autonomous. But 
$$
\dot{x}=rx(1-x+t)
$$
is nonautonomous because of the explicit time dependence on the right-hand side.

## Linear v Nonlinear

Linear systems satisfy a linear supposition principle:  a sum of solutions is itself a solution. This property does not hold in the study of nonlinear systems.

In linear dynamical systems, the dynamics are a function of linear sums of the dependent variables. Hence

$$
\dot{x}=-x
$$
is a linear ordinary differential equation (ODE). But 
$$
\dot{x}=-x^2
$$
is nonlinear.


## Quantitative v qualitative solutions  

You are likely used to solving problems in which an explicit solution can be found. For example, consider the ODE
$$
\dot{x}=-kx, \quad  x(0)=x_0
$$
where $k,x_0 \in \Re^+$ .

We can integrate and express the solution as

$$
x(t)=x_0e^{-kt}
$$

Using the explicit solution we can then answer questions about its behaviour. For example, let's say we want to find the time, $t^*$, at which the solution is half it's maximum. Hence
$$
x(t*)=x_0/2 \implies t^* = \frac{\ln 2}{k}.
$$

However, in the study of nonlinear systems, most problems will not have an explicit solution.   For example, consider the nonlinear ODE

$$
\dot{x}=-\frac{k\sin(x)+\sqrt{x}}{1+x}, \quad  x(0)=x_0
$$
where $0<x_0<\pi$.

I cannot integrate this equation in order to find solutions in terms of standard functions. Hence I cannot quantitatively describe the solution. However, I can identify that

$$
\dot{x}<0, \  \forall \  0<x<\pi.
$$

Hence the solution will decrease in value from the given initial condition. This is an example of a *qualitative* analysis.


## Representing solutions


It is useful to introduce some nomenclature to describe the solutions of a dynamical system.  Consider an ODE
$$
\dot{x}=f(x), \quad x(0)=x_0,
$$
where $f$ is a prescribed function and $x_0$ is an initial condition. At some time $t$ we define

- *phase point* - value of the solution 
- *vector field* - the derivative of the solution, i.e. $f$. The sign represents whether the solution is increasing/decreasing whilst the magnitude represents the rate of change.
- *trajectory* - traces out a solutions as it evolves from initial condition
- *phase portrait* - collection of trajectories (i.e. solutions with different initial conditions)



## Fixed points and their stability 

Many of the dynamical systems that we will study will be nonlinear. Hence it will not be possible to compute exact solutions.

The behaviour of dynamical systems can often be understood by considering the fixed points, i.e. values of the dependent variables at which the dynamics are at steady state. 

Stability analyses are used to investigate the dynamics of perturbations about the steady state. 

## Uniqueness and existence

We will restrict ourselves to problems in which the vector fields are sufficiently well behaved such that unique solutions exist. However, problems can be identified where solutions do not exists or where multiple solutions exist. 

## Nondimensionalisation

In real world problems, variable and parameters typically have units (e.g. time - seconds, Force - Newtons etc.). We can nondimensionalise problems by defining rescaled variables. This process can be used to justify simplifications to models and to reduce the number of parameters.

## Numerical solutions

Numerical solutions are used to numerically compute approximate solutions to problems. The simplest example of a numerical method in a dynamical system is the forward Euler method. Suppose we want to study the ODE

$$
\dot{x}=f(x)
$$

Discretise the independent variable $t$ by defining t=0,\Delta t,2\Delta t,...,T.

Approximate the time derivative

$$
\dot{x}=\frac{dx}{dt}\sim \frac{x(t+\Delta t)-x(t)}{\Delta t}
$$

Hence the ODE can be approximated by the iterative scheme
$$
x(t+\Delta t)=x(t)+\Delta t f(x(t)).
$$

Given an initial condition $x(0)=a$ we can compute the approximate solution at time $\Delta t$.

Numerical solution provide a a very useful way to explore solution behaviour. However, they describe  the quantitative behaviour  of a solution for a particular initial condition and set of  parameter values. 

