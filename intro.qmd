# Introduction

The goal of this module is to provide an introduction to dynamical systems. We will introduce key mathematical concepts and explore examples from physics and biology.  
 
To begin with we introduce some key terminology.


## Discrete v continuous time


### Differential equations

Let $t$ be a continuous variable and $x=x(t)$. Consider the ordinary differential equation (ODE)
$$
\dot{x}=rx(1-x).
$$ {#eq-logdemo}

$\dot{x}$ is used to denote the time derivative, i.e.
$$
\dot{x}:=\frac{dx}{dt}.
$$

Similarly, the second order derivative is represented by 
 $$
\ddot{x}:=\frac{d^2x}{dt^2}.
$$

Many of the  second order ODE problems that we will examine originate from Newton's Second Law, i.e.

$$
m\ddot{x}=F(x)
$$
where $x(t)$ represents the position of a particle at time, $t$, $m$ represents a constant particle mass and $F$ a resultant force.

Consider the case in which $F$ represents a linear restoring force, i.e.
$$
F(x)=-kx.
$$
The equation of motion can be written as 
$$
\ddot{x}=-\mu x,
$$ {#eq-secondorderODE}
where $\mu=-k/m$.



::: {#exm-    }
The app in @fig-popmodel encodes a numerical solution of the second order ODE

$$
a\ddot{x}+b\dot{x}+cx=0.
$$

Use the app to:

- identify appropriate values of the parameters $a$, $b$ and $c$ so that the solution captures the case of a particle of mass ($m$) equal to 3 subjected to a linear restoring force with spring constant ($k$) equal to 5.
- explore the dependence of oscillation period on initial conditions.

Is the behaviour of the numerical solution consistent with @eq-secondorderODE.

:::

::: {#fig-popmodel .content-visible when-format="html"}

```{shinylive-python}
#| standalone: true
#| components: [viewer]
#| viewerHeight: 800

from shiny import App, Inputs, Outputs, Session, render, ui
from shiny import reactive

import numpy as np
from pathlib import Path
import matplotlib.pyplot as plt
from scipy.integrate import odeint

app_ui = ui.page_fluid(
    ui.input_slider(id="a",label="a",min=0.01,max=3,value=0.1,step=0.001),
    ui.input_slider(id="b",label="b",min=0.0,max=15.0,value=10.0,step=0.1),             
    ui.input_slider(id="c",label="c",min=0.0,max=30.0,value=5.0,step=1.0),   
    ui.input_slider(id="y0",label="x(t=0)",min=0.0,max=20.0,value=5.0,step=1.0),
    ui.input_slider(id="y0p",label="dx/dt(t=0)",min=0.0,max=20.0,value=1,step=1.0),
    ui.input_slider(id="T",label="Simulation time",min=0.0,max=60.0,value=20.0,step=0.5),
        ui.output_plot("plot"),
)

def server(input, output, session):
    
    @render.plot
    def plot():
        fig, ax = plt.subplots()
        #ax.set_ylim([-2, 2])
        # Filter fata
        
        
        a=float(input.a())
        b=float(input.b())
        c=float(input.c())
        y_0=float(input.y0())
        y_0_p=float(input.y0p())
        T=float(input.T())
        

        
        # Define rhs of LV ODEs
        def rhs_pop_model(y,t,a,b,c):
          rhs=np.zeros_like(y,dtype=float)

          z=y[1]

          #ay'' + by'+cy=0
          # y'=z
          # z'=y''=-(by'+cy)/a


          dy_dt=y[1]
          dz_dt=-(b*z+c*y[0])/a

          rhs[0]=dy_dt
          rhs[1]=dz_dt

          return rhs

        # Define discretised t domain
        t = np.linspace(0, T, 1000)

        # define initial conditions
        init_cond=[y_0,y_0_p]
        
        # Compute numerical solution of ODEs
        sol1 = odeint(rhs_pop_model, init_cond,t,args=(a,b,c))

        # Plot results
        y=sol1[:,0]
        yp=sol1[:,1]
        
        
        ax.plot(t, y)
        ax.set_xlabel('$t$')
        ax.set_ylabel('$x(t)$')

        plt.grid()
        #plt.show()
    
app = App(app_ui, server)
```

Exploring numerical solutions of a linear second order ODE.
:::




### Difference equations

Suppose that $n$ is a discrete variable. Let $y_n$ represent a dependent variable at iteration $n$. Consider the difference equation
$$
y_{n+1}=ry_n(1-y_n),
$$
where $r\in \Re$.

See this [link](https://dundeemath.github.io/Admissions/posts/RecurrenceRelations.html) for exploration of model solutions.

::: {#fig-logisticmodel .content-visible when-format="html"}

```{shinylive-python}
#| standalone: true
#| viewerHeight: 800




from shiny import App, Inputs, Outputs, Session, render, ui
from shiny import reactive

import numpy as np
from pathlib import Path
import matplotlib.pyplot as plt
from scipy.integrate import odeint

app_ui = ui.page_fluid(
                 
    ui.input_slider(id="u0",label="u_0",min=0.0,max=1.0,value=0.5,step=0.01),
    ui.input_slider(id="T",label="Number of iterations",min=0.0,max=60.0,value=20.0,step=1.0),
    ui.input_slider(id="r_range",label="r zoomed",min=0.0,max=4.0,value=[0.0,4.0],step=0.001),
    ui.input_slider(id="u_range",label="u zoomed",min=0.0,max=1.0,value=[0.0,1.0],step=0.01),ui.output_plot("plot"),
    ui.input_slider(id="r",label="r",min=0.0,max=5.0,value=0.1,step=0.001),
)

def server(input, output, session):
    @output
    @render.plot
    def plot():
        fig, ax = plt.subplots(3,1,figsize=(12, 4))
        #ax.set_ylim([-2, 2])
        # Filter fata
        
        
        r=float(input.r())
        u0=float(input.u0())
        T=int(input.T())
        r_min=float(input.r_range()[0])
        r_max=float(input.r_range()[1])
        u_min=float(input.u_range()[0])
        u_max=float(input.u_range()[1])


        # Define rhs of logistic map 
        def logistic_map(y,t,r):
          rhs=r*y*(1-y)
          return rhs
        
        def DiscreteSol(rhs_pop_model,y_0,t,r):
            y=np.zeros_like(t,dtype=float)
            y[0]=y_0
            for i in t:
                if i>0:

                    y[i]=rhs_pop_model(y[i-1],t[i],r)
            return y

        # Define discretised t domain
        t = np.arange(0, T, 1)
        # define initial conditions
        init_cond=u0
        
        # Compute numerical solution of ODEs
        sol1 = DiscreteSol(logistic_map,init_cond,t,r)

        # Plot results
        y=sol1
        
        ax[0].plot(t,y)
        ax[0].set_xlabel('$n$')
        ax[0].set_ylabel('$y_n$')

        plt.grid()

        # Parameters
        n_iterations = 1000  # total iterations for each value of r
        n_last = 100         # number of iterations to plot (for steady state)
        r_values = np.linspace(0.0, 4.0, 10000)  # range of r values
        u0 = 0.5  # initial population (seed)

        delta=0.25
        #r_min=r-delta
        #r_max=r+delta

        r_values2 = np.linspace(r_min, r_max, 10000)  # range of r values

        # Initialize plot
        x = np.full_like(r_values, u0)
        x2 = np.full_like(r_values2, u0)

        # Iterate and plot bifurcation diagram
         
        for _ in range(n_iterations):
            x = r_values * x * (1 - x)  # logistic map function
            x2 = r_values2 * x2 * (1 - x2)  # logistic map function

            if _ >= (n_iterations - n_last):  # plot only steady state
                ax[1].plot(r_values, x, ',k', alpha=0.25)
                ax[1].plot([r,r],[0,1],'r--')
                ax[2].plot(r_values2, x2, ',k', alpha=0.25)
                ax[2].plot([r,r],[0,1],'r--')

            # Labels and display
            ax[1].set_title("Bifurcation Diagram")
            ax[1].set_xlabel("$r$")
            ax[1].set_ylabel("$y^*$")
            ax[2].set_title("Bifurcation Diagram (zoomed in) ")
            ax[2].set_xlabel("$r$")
            ax[2].set_ylabel("$y^*$")
            ax[2].set_xlim([r_min,r_max])
            ax[2].set_ylim([u_min,u_max])



        plt.show()
    
app = App(app_ui, server)
```

Exploring behaviour of the logistic map using numerical solutions and bifurcation diagrams.
:::


### Key questions to ask of a dynamical system

 - do solutions exist? If so are they unique?
 - Is there an explicit solution?
 - Can we qualitatively describe solution behaviour?
 - How do the solutions depend on the model parameters? 
 - Are their critical values of parameters where solution behaviour changes?


## Autonomous v nonautonomous ODEs

For an autonomous system, the update does not explicitly depend on the independent variable. @eq-logdemo is autonomous. But 
$$
\dot{x}=rx(1-x+t)
$$
is nonautonomous (because of the explicit time dependence on the right-hand side).

## Linear v Nonlinear

Linear systems satisfy a linear supposition principle: a sum of solutions is itself a solution. In general, this property does not hold for nonlinear systems.

In linear dynamical systems, the dynamics are a function of linear sums of the dependent variables. Hence

$$
\dot{x}=-x
$${#eq-linex}
is a linear ordinary differential equation (ODE). But 
$$
\dot{x}=-x^2
$$ {#eq-nonlinex}
is nonlinear.

::: {#exm-    }

Integrate each of @eq-linex and @eq-nonlinex. Use the solutions to demonstrate that the principle of linear superpositions holds for @eq-linex but not for @eq-nonlinex.


:::


## Quantitative v qualitative solutions  

You are likely used to solving problems in which an explicit solution can be found. For example, consider the ODE
$$
\dot{x}=-kx, \quad  x(0)=x_0
$$
where $k,x_0 \in \Re^+$ .

We can integrate and express the solution as

$$
x(t)=x_0e^{-kt}
$$

Using the explicit solution we can then answer questions about its behaviour. For example, let's say we want to find the time, $t^*$, at which the solution is half it's maximum. Hence
$$
x(t*)=x_0/2 \implies t^* = \frac{\ln 2}{k}.
$$

However, almost all problems that we will encounter in the study of nonlinear systems will not have an explicit solution. For example, consider the nonlinear ODE

$$
\dot{x}=-\frac{k\sin(x)+\sqrt{x}}{1+x}, \quad  x(0)=x_0,
$$
where $0<x_0<\pi$.

I cannot integrate this equation in order to find solutions in terms of standard functions. Hence I cannot *quantitatively* describe the solution. However, I can identify that

$$
\dot{x}<0, \  \forall \  0<x<\pi.
$$

Hence the solution will decrease in value from the given initial condition and tend to zero as $t\rightarrow \infty$. This is an example of a *qualitative* analysis.

## Representing solutions

It is useful to define some important concepts that are used to describe the solutions of a dynamical system. Consider an ODE
$$
\dot{\mathbf{x}}=\mathbf{f}(\mathbf{x}), \quad \mathbf{x}(0)=\mathbf{x}_0,
$$
where $\mathbf{f}$ is a prescribed function and $\mathbf{x}_0$ is an initial condition. 

- *phase space* -  a Cartesian coordinate system with dependent variables represented on Cartesian axes
- *phase point* - value of the solution at given time point 
- *vector field* - the derivative of the solution, i.e. $\mathbf{f}$. 
- *trajectory* - a line in phase space that traces out a solution as time evolves (must be tangential to vector field)
- *phase portrait* - collection of trajectories (i.e. solutions with different initial conditions)



## Fixed points and their stability 

Many of the dynamical systems that we will study will be nonlinear. Hence it will not be possible to compute exact solutions.

The behaviour of dynamical systems can often be understood by considering the fixed points, i.e. values of the dependent variables at which the dynamics are at steady state. 

Stability analyses are used to investigate the dynamics of perturbations about the steady state. 

## Uniqueness and existence

We will restrict ourselves to problems in which the vector fields are sufficiently *well behaved* such that unique solutions exist. 

However, it is noted that problems can be identified where solutions do not exist or where multiple solutions exist. 

::: {#exm-    }

Show that the solution to the ODE
$$
\dot{x}=x^2 \quad x(0)=2
$$
blows up after a finite time.
:::


::: {#exm-    }

Show that the solution to the ODE
$$
\dot{x}=\sqrt{x} \quad x(0)=0
$$
is given by
$$
x=\begin{cases}
&0 \ \, t\leq\delta \\
&\frac{(t-\delta)^2}{4}>\delta \  \, t> \delta
\end{cases}
$$
for any $\delta >0$. 
:::


## Nondimensionalisation

In real world problems, variables and parameters typically have units (e.g. time - seconds, Force - Newtons etc.). We can nondimensionalise problems by defining rescaled variables. This process can be used to justify simplifications to models and to reduce the number of parameters.

## Numerical solutions

Numerical solutions are used to numerically compute approximate solutions to problems. The simplest example of a numerical method in a dynamical system is the forward Euler method. Suppose we want to study the ODE

$$
\dot{x}=f(x), \quad x(0)=x_0, \quad 0<t<T.
$$

Discretise the independent variable $t$ by defining $t=0$,$\Delta t$,$2\Delta t$,...,$T=N\Delta T$.

Approximate the time derivative

$$
\dot{x}=\frac{dx}{dt}\sim \frac{x(t+\Delta t)-x(t)}{\Delta t}
$$

Hence the solution at time $t+\Delta t$ can be approximated by
$$
x(t+\Delta t)=x(t)+\Delta t f(x(t)).
$$

Given an initial condition $x(0)=a$ we can compute the approximate solution at time $\Delta t$. Further iteration then allows an approximate solution to be calculated. 

Numerical solutions provide a a very useful way to explore solution behaviour. However, they describe  the quantitative behaviour  of a solution for a particular initial condition and set of parameter values. 


::: {#exm-    }

The app below uses the Forward Euler method  to compute numerical solutions of the ODE
$$
\dot{x}=a+bx+cx^2
$$
in the domain $[0,T]$ with initial condition
$$
x(0)=x_0.
$$

1. Choose model parameters so that the app solves the ODE 
$$
\dot{x}=-bx, \quad x(0)=x_0.
$$
and show that the numerical solution agrees (eye ball norm) with the exact solution (dashed line).
2. Show that the numerical error increases with $\Delta t$. 

:::

::: {#fig-forwardEuler .content-visible when-format="html"}
```{shinylive-python}
#| standalone: true
#| viewerHeight: 800




from shiny import App, Inputs, Outputs, Session, render, ui
from shiny import reactive

import numpy as np
from pathlib import Path
import matplotlib.pyplot as plt
from scipy.integrate import odeint

app_ui = ui.page_fluid(
                 
    ui.input_slider(id="x0",label="x_0",min=0.0,max=10.0,value=0.5,step=0.01),
    ui.input_slider(id="T",label="T",min=0.0,max=60.0,value=20.0,step=1.0),
    ui.input_slider(id="a",label="a",min=-5.0,max=5.0,value=-1.0,step=0.01),
    ui.input_slider(id="b",label="b",min=-5.0,max=5.0,value=2.0,step=0.01),ui.output_plot("plot"),
    ui.input_slider(id="c",label="c",min=-5.0,max=5.0,value=0.1,step=0.01),
    ui.input_slider(id="dt",label="dt",min=0.0,max=1.0,value=0.01,step=0.001),
)

def server(input, output, session):
    @output
    @render.plot
    def plot():
        fig, ax = plt.subplots(1,1,figsize=(12, 4))
       
        x0=float(input.x0())
        T=float(input.T())
        a=float(input.a())
        b=float(input.b())
        c=float(input.c())
        dt=float(input.dt())


        # Define rhs of logistic map 
        def oderhs(y,a,b,c):
          rhs=a+b*y+c*y**2
          return rhs
        
        def FESol(y_0,t,a,b,c,dt):
            y=np.zeros_like(t,dtype=float)
            y[0]=y_0
            for i in range(len(t)):
                if i>0:
                    y[i]=y[i-1]+dt*oderhs(y[i-1],a,b,c)
            return y

        N=int(np.ceil(T/dt))
        # Define discretised t domain
        t = np.linspace(0, T,N)
        
        # Compute numerical solution of ODEs
        sol1 = FESol(x0,t,a,b,c,dt)

        # Plot results
        y=sol1
        
        model_sol=x0*np.exp(b*t)
        ax.plot(t,y,t,model_sol,'--')
        ax.set_xlabel('$t$')
        ax.set_ylabel('$x(t)$')
        ax.set_ylim([0,2*x0])

        fig.legend(['Num','$x_0e^{bt}$'])

        plt.grid()

        plt.show()
    
app = App(app_ui, server)
```

Numerical solution of an ODE with a quadratic right-hand side.
:::
